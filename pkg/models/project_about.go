// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProjectAbout About
//
// State object representing an about page that includes api versioning information.
//
// swagger:discriminator ProjectAbout State object representing an about page that includes api versioning information.
type ProjectAbout interface {
	runtime.Validatable
	runtime.ContextValidatable

	// The latest version of the API in yyyy-MM-dd format (UTC).
	// Required: true
	LatestAPIVersion() *string
	SetLatestAPIVersion(*string)

	// A collection of all currently supported api versions.
	// Required: true
	SupportedApis() []*APIDescription
	SetSupportedApis([]*APIDescription)

	// AdditionalProperties in base type shoud be handled just like regular properties
	// At this moment, the base type property is pushed down to the subtype
}

type projectAbout struct {
	latestApiVersionField *string

	supportedApisField []*APIDescription
}

// LatestAPIVersion gets the latest Api version of this polymorphic type
func (m *projectAbout) LatestAPIVersion() *string {
	return m.latestApiVersionField
}

// SetLatestAPIVersion sets the latest Api version of this polymorphic type
func (m *projectAbout) SetLatestAPIVersion(val *string) {
	m.latestApiVersionField = val
}

// SupportedApis gets the supported apis of this polymorphic type
func (m *projectAbout) SupportedApis() []*APIDescription {
	return m.supportedApisField
}

// SetSupportedApis sets the supported apis of this polymorphic type
func (m *projectAbout) SetSupportedApis(val []*APIDescription) {
	m.supportedApisField = val
}

// UnmarshalProjectAboutSlice unmarshals polymorphic slices of ProjectAbout
func UnmarshalProjectAboutSlice(reader io.Reader, consumer runtime.Consumer) ([]ProjectAbout, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []ProjectAbout
	for _, element := range elements {
		obj, err := unmarshalProjectAbout(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalProjectAbout unmarshals polymorphic ProjectAbout
func UnmarshalProjectAbout(reader io.Reader, consumer runtime.Consumer) (ProjectAbout, error) {
	// we need to read this twice, so first into a buffer
	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalProjectAbout(data, consumer)
}

func unmarshalProjectAbout(data []byte, consumer runtime.Consumer) (ProjectAbout, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the State object representing an about page that includes api versioning information. property.
	var getType struct {
		StateObjectRepresentingAnAboutPageThatIncludesAPIVersioningInformation string `json:"State object representing an about page that includes api versioning information."`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("State object representing an about page that includes api versioning information.", "body", getType.StateObjectRepresentingAnAboutPageThatIncludesAPIVersioningInformation); err != nil {
		return nil, err
	}

	// The value of State object representing an about page that includes api versioning information. is used to determine which type to create and unmarshal the data into
	switch getType.StateObjectRepresentingAnAboutPageThatIncludesAPIVersioningInformation {
	case "ProjectAbout":
		var result projectAbout
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	}
	return nil, errors.New(422, "invalid State object representing an about page that includes api versioning information. value: %q", getType.StateObjectRepresentingAnAboutPageThatIncludesAPIVersioningInformation)
}

// Validate validates this project about
func (m *projectAbout) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLatestAPIVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportedApis(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *projectAbout) validateLatestAPIVersion(formats strfmt.Registry) error {

	if err := validate.Required("latestApiVersion", "body", m.LatestAPIVersion()); err != nil {
		return err
	}

	return nil
}

func (m *projectAbout) validateSupportedApis(formats strfmt.Registry) error {

	if err := validate.Required("supportedApis", "body", m.SupportedApis()); err != nil {
		return err
	}

	for i := 0; i < len(m.SupportedApis()); i++ {
		if swag.IsZero(m.supportedApisField[i]) { // not required
			continue
		}

		if m.supportedApisField[i] != nil {
			if err := m.supportedApisField[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("supportedApis" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("supportedApis" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this project about based on the context it is used
func (m *projectAbout) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSupportedApis(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *projectAbout) contextValidateSupportedApis(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SupportedApis()); i++ {

		if m.supportedApisField[i] != nil {
			if err := m.supportedApisField[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("supportedApis" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("supportedApis" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}
