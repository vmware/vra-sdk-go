// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// UserExperiencesResponse UserExperiencesResponse
//
// # Project callback response containing set of user experiences that needs to be activated
//
// swagger:discriminator UserExperiencesResponse Project callback response containing set of user experiences that needs to be activated
type UserExperiencesResponse interface {
	runtime.Validatable
	runtime.ContextValidatable

	// Specifies if all services have responded or not
	CompleteResponse() bool
	SetCompleteResponse(bool)

	// Set of available User experiences
	UserExperiences() []string
	SetUserExperiences([]string)

	// AdditionalProperties in base type shoud be handled just like regular properties
	// At this moment, the base type property is pushed down to the subtype
}

type userExperiencesResponse struct {
	completeResponseField bool

	userExperiencesField []string
}

// CompleteResponse gets the complete response of this polymorphic type
func (m *userExperiencesResponse) CompleteResponse() bool {
	return m.completeResponseField
}

// SetCompleteResponse sets the complete response of this polymorphic type
func (m *userExperiencesResponse) SetCompleteResponse(val bool) {
	m.completeResponseField = val
}

// UserExperiences gets the user experiences of this polymorphic type
func (m *userExperiencesResponse) UserExperiences() []string {
	return m.userExperiencesField
}

// SetUserExperiences sets the user experiences of this polymorphic type
func (m *userExperiencesResponse) SetUserExperiences(val []string) {
	m.userExperiencesField = val
}

// UnmarshalUserExperiencesResponseSlice unmarshals polymorphic slices of UserExperiencesResponse
func UnmarshalUserExperiencesResponseSlice(reader io.Reader, consumer runtime.Consumer) ([]UserExperiencesResponse, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []UserExperiencesResponse
	for _, element := range elements {
		obj, err := unmarshalUserExperiencesResponse(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalUserExperiencesResponse unmarshals polymorphic UserExperiencesResponse
func UnmarshalUserExperiencesResponse(reader io.Reader, consumer runtime.Consumer) (UserExperiencesResponse, error) {
	// we need to read this twice, so first into a buffer
	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalUserExperiencesResponse(data, consumer)
}

func unmarshalUserExperiencesResponse(data []byte, consumer runtime.Consumer) (UserExperiencesResponse, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the Project callback response containing set of user experiences that needs to be activated property.
	var getType struct {
		ProjectCallbackResponseContainingSetOfUserExperiencesThatNeedsToBeActivated string `json:"Project callback response containing set of user experiences that needs to be activated"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("Project callback response containing set of user experiences that needs to be activated", "body", getType.ProjectCallbackResponseContainingSetOfUserExperiencesThatNeedsToBeActivated); err != nil {
		return nil, err
	}

	// The value of Project callback response containing set of user experiences that needs to be activated is used to determine which type to create and unmarshal the data into
	switch getType.ProjectCallbackResponseContainingSetOfUserExperiencesThatNeedsToBeActivated {
	case "UserExperiencesResponse":
		var result userExperiencesResponse
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	}
	return nil, errors.New(422, "invalid Project callback response containing set of user experiences that needs to be activated value: %q", getType.ProjectCallbackResponseContainingSetOfUserExperiencesThatNeedsToBeActivated)
}

// Validate validates this user experiences response
func (m *userExperiencesResponse) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this user experiences response based on context it is used
func (m *userExperiencesResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}
