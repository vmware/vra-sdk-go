// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// X509Certificate X509Certificate
//
// swagger:model X509Certificate
type X509Certificate struct {

	// encoded
	// Format: byte
	Encoded strfmt.Base64 `json:"encoded,omitempty"`

	issuerDNField Principal

	// not after
	// Format: date-time
	NotAfter strfmt.DateTime `json:"notAfter,omitempty"`

	// not before
	// Format: date-time
	NotBefore strfmt.DateTime `json:"notBefore,omitempty"`

	// public key
	PublicKey *PublicKey `json:"publicKey,omitempty"`

	// serial number
	SerialNumber int64 `json:"serialNumber,omitempty"`

	// sig alg name
	SigAlgName string `json:"sigAlgName,omitempty"`

	// sig alg o ID
	SigAlgOID string `json:"sigAlgOID,omitempty"`

	// sig alg params
	// Format: byte
	SigAlgParams strfmt.Base64 `json:"sigAlgParams,omitempty"`

	subjectDNField Principal

	// version
	Version int32 `json:"version,omitempty"`
}

// IssuerDN gets the issuer d n of this base type
func (m *X509Certificate) IssuerDN() Principal {
	return m.issuerDNField
}

// SetIssuerDN sets the issuer d n of this base type
func (m *X509Certificate) SetIssuerDN(val Principal) {
	m.issuerDNField = val
}

// SubjectDN gets the subject d n of this base type
func (m *X509Certificate) SubjectDN() Principal {
	return m.subjectDNField
}

// SetSubjectDN sets the subject d n of this base type
func (m *X509Certificate) SetSubjectDN(val Principal) {
	m.subjectDNField = val
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *X509Certificate) UnmarshalJSON(raw []byte) error {
	var data struct {
		Encoded strfmt.Base64 `json:"encoded,omitempty"`

		IssuerDN json.RawMessage `json:"issuerDN,omitempty"`

		NotAfter strfmt.DateTime `json:"notAfter,omitempty"`

		NotBefore strfmt.DateTime `json:"notBefore,omitempty"`

		PublicKey *PublicKey `json:"publicKey,omitempty"`

		SerialNumber int64 `json:"serialNumber,omitempty"`

		SigAlgName string `json:"sigAlgName,omitempty"`

		SigAlgOID string `json:"sigAlgOID,omitempty"`

		SigAlgParams strfmt.Base64 `json:"sigAlgParams,omitempty"`

		SubjectDN json.RawMessage `json:"subjectDN,omitempty"`

		Version int32 `json:"version,omitempty"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var propIssuerDN Principal
	if string(data.IssuerDN) != "null" {
		issuerDN, err := UnmarshalPrincipal(bytes.NewBuffer(data.IssuerDN), runtime.JSONConsumer())
		if err != nil && err != io.EOF {
			return err
		}
		propIssuerDN = issuerDN
	}
	var propSubjectDN Principal
	if string(data.SubjectDN) != "null" {
		subjectDN, err := UnmarshalPrincipal(bytes.NewBuffer(data.SubjectDN), runtime.JSONConsumer())
		if err != nil && err != io.EOF {
			return err
		}
		propSubjectDN = subjectDN
	}

	var result X509Certificate

	// encoded
	result.Encoded = data.Encoded

	// issuerDN
	result.issuerDNField = propIssuerDN

	// notAfter
	result.NotAfter = data.NotAfter

	// notBefore
	result.NotBefore = data.NotBefore

	// publicKey
	result.PublicKey = data.PublicKey

	// serialNumber
	result.SerialNumber = data.SerialNumber

	// sigAlgName
	result.SigAlgName = data.SigAlgName

	// sigAlgOID
	result.SigAlgOID = data.SigAlgOID

	// sigAlgParams
	result.SigAlgParams = data.SigAlgParams

	// subjectDN
	result.subjectDNField = propSubjectDN

	// version
	result.Version = data.Version

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m X509Certificate) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {
		Encoded strfmt.Base64 `json:"encoded,omitempty"`

		NotAfter strfmt.DateTime `json:"notAfter,omitempty"`

		NotBefore strfmt.DateTime `json:"notBefore,omitempty"`

		PublicKey *PublicKey `json:"publicKey,omitempty"`

		SerialNumber int64 `json:"serialNumber,omitempty"`

		SigAlgName string `json:"sigAlgName,omitempty"`

		SigAlgOID string `json:"sigAlgOID,omitempty"`

		SigAlgParams strfmt.Base64 `json:"sigAlgParams,omitempty"`

		Version int32 `json:"version,omitempty"`
	}{

		Encoded: m.Encoded,

		NotAfter: m.NotAfter,

		NotBefore: m.NotBefore,

		PublicKey: m.PublicKey,

		SerialNumber: m.SerialNumber,

		SigAlgName: m.SigAlgName,

		SigAlgOID: m.SigAlgOID,

		SigAlgParams: m.SigAlgParams,

		Version: m.Version,
	})
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		IssuerDN Principal `json:"issuerDN,omitempty"`

		SubjectDN Principal `json:"subjectDN,omitempty"`
	}{

		IssuerDN: m.issuerDNField,

		SubjectDN: m.subjectDNField,
	})
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this x509 certificate
func (m *X509Certificate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIssuerDN(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotAfter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotBefore(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublicKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubjectDN(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *X509Certificate) validateIssuerDN(formats strfmt.Registry) error {
	if swag.IsZero(m.IssuerDN()) { // not required
		return nil
	}

	if err := m.IssuerDN().Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("issuerDN")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("issuerDN")
		}
		return err
	}

	return nil
}

func (m *X509Certificate) validateNotAfter(formats strfmt.Registry) error {
	if swag.IsZero(m.NotAfter) { // not required
		return nil
	}

	if err := validate.FormatOf("notAfter", "body", "date-time", m.NotAfter.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *X509Certificate) validateNotBefore(formats strfmt.Registry) error {
	if swag.IsZero(m.NotBefore) { // not required
		return nil
	}

	if err := validate.FormatOf("notBefore", "body", "date-time", m.NotBefore.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *X509Certificate) validatePublicKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PublicKey) { // not required
		return nil
	}

	if m.PublicKey != nil {
		if err := m.PublicKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("publicKey")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("publicKey")
			}
			return err
		}
	}

	return nil
}

func (m *X509Certificate) validateSubjectDN(formats strfmt.Registry) error {
	if swag.IsZero(m.SubjectDN()) { // not required
		return nil
	}

	if err := m.SubjectDN().Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("subjectDN")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("subjectDN")
		}
		return err
	}

	return nil
}

// ContextValidate validate this x509 certificate based on the context it is used
func (m *X509Certificate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIssuerDN(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePublicKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubjectDN(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *X509Certificate) contextValidateIssuerDN(ctx context.Context, formats strfmt.Registry) error {

	if err := m.IssuerDN().ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("issuerDN")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("issuerDN")
		}
		return err
	}

	return nil
}

func (m *X509Certificate) contextValidatePublicKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PublicKey != nil {
		if err := m.PublicKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("publicKey")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("publicKey")
			}
			return err
		}
	}

	return nil
}

func (m *X509Certificate) contextValidateSubjectDN(ctx context.Context, formats strfmt.Registry) error {

	if err := m.SubjectDN().ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("subjectDN")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("subjectDN")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *X509Certificate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *X509Certificate) UnmarshalBinary(b []byte) error {
	var res X509Certificate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
