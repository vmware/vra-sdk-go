// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GerritTriggerSpec GerritTriggerSpec
//
// The configurations of a Gerrit Trigger decides which pipeline is required to be triggered depending on kind of event received.
//
// swagger:discriminator GerritTriggerSpec The configurations of a Gerrit Trigger decides which pipeline is required to be triggered depending on kind of event received.
type GerritTriggerSpec interface {
	runtime.Validatable
	runtime.ContextValidatable

	// Gerrit Project Branch on which the change has to be monitored.
	// Example: master
	// Required: true
	Branch() *string
	SetBranch(*string)

	// The configuration of an Gerrit Event.
	// Example: [{"eventType":"change-merged","failureComment":"Pipeline Execution Failed","input":{},"pipeline":"rest_pipeline","successComment":"Pipeline Execution Successful"},{"eventType":"patchset-created","failureComment":"Pipeline Failed","input":{},"pipeline":"rest_pipeline","successComment":"Pipeline Completed","verifiedLabel":"Verified"}]
	Configurations() []*GerritTriggerSpecGerritEventConfiguration
	SetConfigurations([]*GerritTriggerSpecGerritEventConfiguration)

	// A human-friendly description.
	// Required: true
	Description() *string
	SetDescription(*string)

	// Indicates that this trigger will be addressed on receiving respective events.
	// Example: true
	Enabled() bool
	SetEnabled(bool)

	// Provide file exclusions as conditions for the trigger.
	// Example: [{"type":"PLAIN","value":"example.txt"}]
	Exclusions() []*GerritTriggerFileFilter
	SetExclusions([]*GerritTriggerFileFilter)

	// Gerrit Project which is to be monitored for the change.
	// Example: TestGerritProject
	// Required: true
	GerritProject() *string
	SetGerritProject(*string)

	// Provide file inclusions as conditions for the trigger.
	// Example: [{"type":"PLAIN","value":"example.txt"}]
	Inclusions() []*GerritTriggerFileFilter
	SetInclusions([]*GerritTriggerFileFilter)

	// Gerrit Listener which will receive the events for this trigger.
	// Example: Gerrit-Listener
	// Required: true
	Listener() *string
	SetListener(*string)

	// A human-friendly name used as an identifier in APIs that support this option
	// Example: My-Name
	// Required: true
	Name() *string
	SetName(*string)

	// Prioritize Exclusion ensures that pipelines are not triggered even if any of the files in a commit match the specified files in the exclusion paths or regex.
	// Example: true
	PrioritizeExclusion() bool
	SetPrioritizeExclusion(bool)

	// The project this entity belongs to.
	// Example: My-Project
	Project() string
	SetProject(string)

	// AdditionalProperties in base type shoud be handled just like regular properties
	// At this moment, the base type property is pushed down to the subtype
}

type gerritTriggerSpec struct {
	branchField *string

	configurationsField []*GerritTriggerSpecGerritEventConfiguration

	descriptionField *string

	enabledField bool

	exclusionsField []*GerritTriggerFileFilter

	gerritProjectField *string

	inclusionsField []*GerritTriggerFileFilter

	listenerField *string

	nameField *string

	prioritizeExclusionField bool

	projectField string
}

// Branch gets the branch of this polymorphic type
func (m *gerritTriggerSpec) Branch() *string {
	return m.branchField
}

// SetBranch sets the branch of this polymorphic type
func (m *gerritTriggerSpec) SetBranch(val *string) {
	m.branchField = val
}

// Configurations gets the configurations of this polymorphic type
func (m *gerritTriggerSpec) Configurations() []*GerritTriggerSpecGerritEventConfiguration {
	return m.configurationsField
}

// SetConfigurations sets the configurations of this polymorphic type
func (m *gerritTriggerSpec) SetConfigurations(val []*GerritTriggerSpecGerritEventConfiguration) {
	m.configurationsField = val
}

// Description gets the description of this polymorphic type
func (m *gerritTriggerSpec) Description() *string {
	return m.descriptionField
}

// SetDescription sets the description of this polymorphic type
func (m *gerritTriggerSpec) SetDescription(val *string) {
	m.descriptionField = val
}

// Enabled gets the enabled of this polymorphic type
func (m *gerritTriggerSpec) Enabled() bool {
	return m.enabledField
}

// SetEnabled sets the enabled of this polymorphic type
func (m *gerritTriggerSpec) SetEnabled(val bool) {
	m.enabledField = val
}

// Exclusions gets the exclusions of this polymorphic type
func (m *gerritTriggerSpec) Exclusions() []*GerritTriggerFileFilter {
	return m.exclusionsField
}

// SetExclusions sets the exclusions of this polymorphic type
func (m *gerritTriggerSpec) SetExclusions(val []*GerritTriggerFileFilter) {
	m.exclusionsField = val
}

// GerritProject gets the gerrit project of this polymorphic type
func (m *gerritTriggerSpec) GerritProject() *string {
	return m.gerritProjectField
}

// SetGerritProject sets the gerrit project of this polymorphic type
func (m *gerritTriggerSpec) SetGerritProject(val *string) {
	m.gerritProjectField = val
}

// Inclusions gets the inclusions of this polymorphic type
func (m *gerritTriggerSpec) Inclusions() []*GerritTriggerFileFilter {
	return m.inclusionsField
}

// SetInclusions sets the inclusions of this polymorphic type
func (m *gerritTriggerSpec) SetInclusions(val []*GerritTriggerFileFilter) {
	m.inclusionsField = val
}

// Listener gets the listener of this polymorphic type
func (m *gerritTriggerSpec) Listener() *string {
	return m.listenerField
}

// SetListener sets the listener of this polymorphic type
func (m *gerritTriggerSpec) SetListener(val *string) {
	m.listenerField = val
}

// Name gets the name of this polymorphic type
func (m *gerritTriggerSpec) Name() *string {
	return m.nameField
}

// SetName sets the name of this polymorphic type
func (m *gerritTriggerSpec) SetName(val *string) {
	m.nameField = val
}

// PrioritizeExclusion gets the prioritize exclusion of this polymorphic type
func (m *gerritTriggerSpec) PrioritizeExclusion() bool {
	return m.prioritizeExclusionField
}

// SetPrioritizeExclusion sets the prioritize exclusion of this polymorphic type
func (m *gerritTriggerSpec) SetPrioritizeExclusion(val bool) {
	m.prioritizeExclusionField = val
}

// Project gets the project of this polymorphic type
func (m *gerritTriggerSpec) Project() string {
	return m.projectField
}

// SetProject sets the project of this polymorphic type
func (m *gerritTriggerSpec) SetProject(val string) {
	m.projectField = val
}

// UnmarshalGerritTriggerSpecSlice unmarshals polymorphic slices of GerritTriggerSpec
func UnmarshalGerritTriggerSpecSlice(reader io.Reader, consumer runtime.Consumer) ([]GerritTriggerSpec, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []GerritTriggerSpec
	for _, element := range elements {
		obj, err := unmarshalGerritTriggerSpec(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalGerritTriggerSpec unmarshals polymorphic GerritTriggerSpec
func UnmarshalGerritTriggerSpec(reader io.Reader, consumer runtime.Consumer) (GerritTriggerSpec, error) {
	// we need to read this twice, so first into a buffer
	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalGerritTriggerSpec(data, consumer)
}

func unmarshalGerritTriggerSpec(data []byte, consumer runtime.Consumer) (GerritTriggerSpec, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the The configurations of a Gerrit Trigger decides which pipeline is required to be triggered depending on kind of event received. property.
	var getType struct {
		TheConfigurationsOfaGerritTriggerDecidesWhichPipelineIsRequiredToBeTriggeredDependingOnKindOfEventReceived string `json:"The configurations of a Gerrit Trigger decides which pipeline is required to be triggered depending on kind of event received."`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("The configurations of a Gerrit Trigger decides which pipeline is required to be triggered depending on kind of event received.", "body", getType.TheConfigurationsOfaGerritTriggerDecidesWhichPipelineIsRequiredToBeTriggeredDependingOnKindOfEventReceived); err != nil {
		return nil, err
	}

	// The value of The configurations of a Gerrit Trigger decides which pipeline is required to be triggered depending on kind of event received. is used to determine which type to create and unmarshal the data into
	switch getType.TheConfigurationsOfaGerritTriggerDecidesWhichPipelineIsRequiredToBeTriggeredDependingOnKindOfEventReceived {
	case "GerritTriggerSpec":
		var result gerritTriggerSpec
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	}
	return nil, errors.New(422, "invalid The configurations of a Gerrit Trigger decides which pipeline is required to be triggered depending on kind of event received. value: %q", getType.TheConfigurationsOfaGerritTriggerDecidesWhichPipelineIsRequiredToBeTriggeredDependingOnKindOfEventReceived)
}

// Validate validates this gerrit trigger spec
func (m *gerritTriggerSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBranch(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigurations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExclusions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGerritProject(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInclusions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateListener(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *gerritTriggerSpec) validateBranch(formats strfmt.Registry) error {

	if err := validate.Required("branch", "body", m.Branch()); err != nil {
		return err
	}

	return nil
}

func (m *gerritTriggerSpec) validateConfigurations(formats strfmt.Registry) error {
	if swag.IsZero(m.Configurations()) { // not required
		return nil
	}

	for i := 0; i < len(m.Configurations()); i++ {
		if swag.IsZero(m.configurationsField[i]) { // not required
			continue
		}

		if m.configurationsField[i] != nil {
			if err := m.configurationsField[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("configurations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("configurations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *gerritTriggerSpec) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description()); err != nil {
		return err
	}

	return nil
}

func (m *gerritTriggerSpec) validateExclusions(formats strfmt.Registry) error {
	if swag.IsZero(m.Exclusions()) { // not required
		return nil
	}

	for i := 0; i < len(m.Exclusions()); i++ {
		if swag.IsZero(m.exclusionsField[i]) { // not required
			continue
		}

		if m.exclusionsField[i] != nil {
			if err := m.exclusionsField[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("exclusions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("exclusions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *gerritTriggerSpec) validateGerritProject(formats strfmt.Registry) error {

	if err := validate.Required("gerritProject", "body", m.GerritProject()); err != nil {
		return err
	}

	return nil
}

func (m *gerritTriggerSpec) validateInclusions(formats strfmt.Registry) error {
	if swag.IsZero(m.Inclusions()) { // not required
		return nil
	}

	for i := 0; i < len(m.Inclusions()); i++ {
		if swag.IsZero(m.inclusionsField[i]) { // not required
			continue
		}

		if m.inclusionsField[i] != nil {
			if err := m.inclusionsField[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inclusions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("inclusions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *gerritTriggerSpec) validateListener(formats strfmt.Registry) error {

	if err := validate.Required("listener", "body", m.Listener()); err != nil {
		return err
	}

	return nil
}

func (m *gerritTriggerSpec) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name()); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this gerrit trigger spec based on the context it is used
func (m *gerritTriggerSpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateConfigurations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExclusions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInclusions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *gerritTriggerSpec) contextValidateConfigurations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Configurations()); i++ {

		if m.configurationsField[i] != nil {
			if err := m.configurationsField[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("configurations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("configurations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *gerritTriggerSpec) contextValidateExclusions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Exclusions()); i++ {

		if m.exclusionsField[i] != nil {
			if err := m.exclusionsField[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("exclusions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("exclusions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *gerritTriggerSpec) contextValidateInclusions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Inclusions()); i++ {

		if m.inclusionsField[i] != nil {
			if err := m.inclusionsField[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inclusions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("inclusions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}
