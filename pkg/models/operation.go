// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Operation Operation
//
// swagger:model Operation
type Operation struct {

	// action
	// Enum: [GET POST PATCH PUT DELETE OPTIONS]
	Action string `json:"action,omitempty"`

	// authorization context
	AuthorizationContext *AuthorizationContext `json:"authorizationContext,omitempty"`

	// body raw
	BodyRaw interface{} `json:"bodyRaw,omitempty"`

	// commit
	Commit bool `json:"commit,omitempty"`

	// completion
	Completion CompletionHandler `json:"completion,omitempty"`

	// connection sharing
	ConnectionSharing bool `json:"connectionSharing,omitempty"`

	// connection tag
	ConnectionTag string `json:"connectionTag,omitempty"`

	// content length
	ContentLength int64 `json:"contentLength,omitempty"`

	// content type
	ContentType string `json:"contentType,omitempty"`

	// context Id
	ContextID string `json:"contextId,omitempty"`

	// cookies
	Cookies map[string]string `json:"cookies,omitempty"`

	// error response body
	ErrorResponseBody *ServiceErrorResponse `json:"errorResponseBody,omitempty"`

	// expiration micros utc
	ExpirationMicrosUtc int64 `json:"expirationMicrosUtc,omitempty"`

	// failure logging disabled
	FailureLoggingDisabled bool `json:"failureLoggingDisabled,omitempty"`

	// forwarded
	Forwarded bool `json:"forwarded,omitempty"`

	// forwarding disabled
	ForwardingDisabled bool `json:"forwardingDisabled,omitempty"`

	// from replication
	FromReplication bool `json:"fromReplication,omitempty"`

	// id
	ID int64 `json:"id,omitempty"`

	// keep alive
	KeepAlive bool `json:"keepAlive,omitempty"`

	// notification
	Notification bool `json:"notification,omitempty"`

	// notification disabled
	NotificationDisabled bool `json:"notificationDisabled,omitempty"`

	// options
	Options []string `json:"options"`

	// peer certificate chain
	PeerCertificateChain []*X509Certificate `json:"peerCertificateChain"`

	peerPrincipalField Principal

	// referer
	Referer *URI `json:"referer,omitempty"`

	// referer as string
	RefererAsString string `json:"refererAsString,omitempty"`

	// remote
	Remote bool `json:"remote,omitempty"`

	// replication disabled
	ReplicationDisabled bool `json:"replicationDisabled,omitempty"`

	// request headers
	RequestHeaders map[string]string `json:"requestHeaders,omitempty"`

	// response headers
	ResponseHeaders map[string]string `json:"responseHeaders,omitempty"`

	// retries remaining
	RetriesRemaining int32 `json:"retriesRemaining,omitempty"`

	// retry count
	RetryCount int32 `json:"retryCount,omitempty"`

	// socket context
	SocketContext *SocketContext `json:"socketContext,omitempty"`

	// status code
	StatusCode int32 `json:"statusCode,omitempty"`

	// synchronize
	Synchronize bool `json:"synchronize,omitempty"`

	// synchronize owner
	SynchronizeOwner bool `json:"synchronizeOwner,omitempty"`

	// synchronize peer
	SynchronizePeer bool `json:"synchronizePeer,omitempty"`

	// target replicated
	TargetReplicated bool `json:"targetReplicated,omitempty"`

	// transaction Id
	TransactionID string `json:"transactionId,omitempty"`

	// update
	Update bool `json:"update,omitempty"`

	// uri
	URI *URI `json:"uri,omitempty"`

	// within transaction
	WithinTransaction bool `json:"withinTransaction,omitempty"`
}

// PeerPrincipal gets the peer principal of this base type
func (m *Operation) PeerPrincipal() Principal {
	return m.peerPrincipalField
}

// SetPeerPrincipal sets the peer principal of this base type
func (m *Operation) SetPeerPrincipal(val Principal) {
	m.peerPrincipalField = val
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *Operation) UnmarshalJSON(raw []byte) error {
	var data struct {
		Action string `json:"action,omitempty"`

		AuthorizationContext *AuthorizationContext `json:"authorizationContext,omitempty"`

		BodyRaw interface{} `json:"bodyRaw,omitempty"`

		Commit bool `json:"commit,omitempty"`

		Completion CompletionHandler `json:"completion,omitempty"`

		ConnectionSharing bool `json:"connectionSharing,omitempty"`

		ConnectionTag string `json:"connectionTag,omitempty"`

		ContentLength int64 `json:"contentLength,omitempty"`

		ContentType string `json:"contentType,omitempty"`

		ContextID string `json:"contextId,omitempty"`

		Cookies map[string]string `json:"cookies,omitempty"`

		ErrorResponseBody *ServiceErrorResponse `json:"errorResponseBody,omitempty"`

		ExpirationMicrosUtc int64 `json:"expirationMicrosUtc,omitempty"`

		FailureLoggingDisabled bool `json:"failureLoggingDisabled,omitempty"`

		Forwarded bool `json:"forwarded,omitempty"`

		ForwardingDisabled bool `json:"forwardingDisabled,omitempty"`

		FromReplication bool `json:"fromReplication,omitempty"`

		ID int64 `json:"id,omitempty"`

		KeepAlive bool `json:"keepAlive,omitempty"`

		Notification bool `json:"notification,omitempty"`

		NotificationDisabled bool `json:"notificationDisabled,omitempty"`

		Options []string `json:"options"`

		PeerCertificateChain []*X509Certificate `json:"peerCertificateChain"`

		PeerPrincipal json.RawMessage `json:"peerPrincipal,omitempty"`

		Referer *URI `json:"referer,omitempty"`

		RefererAsString string `json:"refererAsString,omitempty"`

		Remote bool `json:"remote,omitempty"`

		ReplicationDisabled bool `json:"replicationDisabled,omitempty"`

		RequestHeaders map[string]string `json:"requestHeaders,omitempty"`

		ResponseHeaders map[string]string `json:"responseHeaders,omitempty"`

		RetriesRemaining int32 `json:"retriesRemaining,omitempty"`

		RetryCount int32 `json:"retryCount,omitempty"`

		SocketContext *SocketContext `json:"socketContext,omitempty"`

		StatusCode int32 `json:"statusCode,omitempty"`

		Synchronize bool `json:"synchronize,omitempty"`

		SynchronizeOwner bool `json:"synchronizeOwner,omitempty"`

		SynchronizePeer bool `json:"synchronizePeer,omitempty"`

		TargetReplicated bool `json:"targetReplicated,omitempty"`

		TransactionID string `json:"transactionId,omitempty"`

		Update bool `json:"update,omitempty"`

		URI *URI `json:"uri,omitempty"`

		WithinTransaction bool `json:"withinTransaction,omitempty"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var propPeerPrincipal Principal
	if string(data.PeerPrincipal) != "null" {
		peerPrincipal, err := UnmarshalPrincipal(bytes.NewBuffer(data.PeerPrincipal), runtime.JSONConsumer())
		if err != nil && err != io.EOF {
			return err
		}
		propPeerPrincipal = peerPrincipal
	}

	var result Operation

	// action
	result.Action = data.Action

	// authorizationContext
	result.AuthorizationContext = data.AuthorizationContext

	// bodyRaw
	result.BodyRaw = data.BodyRaw

	// commit
	result.Commit = data.Commit

	// completion
	result.Completion = data.Completion

	// connectionSharing
	result.ConnectionSharing = data.ConnectionSharing

	// connectionTag
	result.ConnectionTag = data.ConnectionTag

	// contentLength
	result.ContentLength = data.ContentLength

	// contentType
	result.ContentType = data.ContentType

	// contextId
	result.ContextID = data.ContextID

	// cookies
	result.Cookies = data.Cookies

	// errorResponseBody
	result.ErrorResponseBody = data.ErrorResponseBody

	// expirationMicrosUtc
	result.ExpirationMicrosUtc = data.ExpirationMicrosUtc

	// failureLoggingDisabled
	result.FailureLoggingDisabled = data.FailureLoggingDisabled

	// forwarded
	result.Forwarded = data.Forwarded

	// forwardingDisabled
	result.ForwardingDisabled = data.ForwardingDisabled

	// fromReplication
	result.FromReplication = data.FromReplication

	// id
	result.ID = data.ID

	// keepAlive
	result.KeepAlive = data.KeepAlive

	// notification
	result.Notification = data.Notification

	// notificationDisabled
	result.NotificationDisabled = data.NotificationDisabled

	// options
	result.Options = data.Options

	// peerCertificateChain
	result.PeerCertificateChain = data.PeerCertificateChain

	// peerPrincipal
	result.peerPrincipalField = propPeerPrincipal

	// referer
	result.Referer = data.Referer

	// refererAsString
	result.RefererAsString = data.RefererAsString

	// remote
	result.Remote = data.Remote

	// replicationDisabled
	result.ReplicationDisabled = data.ReplicationDisabled

	// requestHeaders
	result.RequestHeaders = data.RequestHeaders

	// responseHeaders
	result.ResponseHeaders = data.ResponseHeaders

	// retriesRemaining
	result.RetriesRemaining = data.RetriesRemaining

	// retryCount
	result.RetryCount = data.RetryCount

	// socketContext
	result.SocketContext = data.SocketContext

	// statusCode
	result.StatusCode = data.StatusCode

	// synchronize
	result.Synchronize = data.Synchronize

	// synchronizeOwner
	result.SynchronizeOwner = data.SynchronizeOwner

	// synchronizePeer
	result.SynchronizePeer = data.SynchronizePeer

	// targetReplicated
	result.TargetReplicated = data.TargetReplicated

	// transactionId
	result.TransactionID = data.TransactionID

	// update
	result.Update = data.Update

	// uri
	result.URI = data.URI

	// withinTransaction
	result.WithinTransaction = data.WithinTransaction

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m Operation) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {
		Action string `json:"action,omitempty"`

		AuthorizationContext *AuthorizationContext `json:"authorizationContext,omitempty"`

		BodyRaw interface{} `json:"bodyRaw,omitempty"`

		Commit bool `json:"commit,omitempty"`

		Completion CompletionHandler `json:"completion,omitempty"`

		ConnectionSharing bool `json:"connectionSharing,omitempty"`

		ConnectionTag string `json:"connectionTag,omitempty"`

		ContentLength int64 `json:"contentLength,omitempty"`

		ContentType string `json:"contentType,omitempty"`

		ContextID string `json:"contextId,omitempty"`

		Cookies map[string]string `json:"cookies,omitempty"`

		ErrorResponseBody *ServiceErrorResponse `json:"errorResponseBody,omitempty"`

		ExpirationMicrosUtc int64 `json:"expirationMicrosUtc,omitempty"`

		FailureLoggingDisabled bool `json:"failureLoggingDisabled,omitempty"`

		Forwarded bool `json:"forwarded,omitempty"`

		ForwardingDisabled bool `json:"forwardingDisabled,omitempty"`

		FromReplication bool `json:"fromReplication,omitempty"`

		ID int64 `json:"id,omitempty"`

		KeepAlive bool `json:"keepAlive,omitempty"`

		Notification bool `json:"notification,omitempty"`

		NotificationDisabled bool `json:"notificationDisabled,omitempty"`

		Options []string `json:"options"`

		PeerCertificateChain []*X509Certificate `json:"peerCertificateChain"`

		Referer *URI `json:"referer,omitempty"`

		RefererAsString string `json:"refererAsString,omitempty"`

		Remote bool `json:"remote,omitempty"`

		ReplicationDisabled bool `json:"replicationDisabled,omitempty"`

		RequestHeaders map[string]string `json:"requestHeaders,omitempty"`

		ResponseHeaders map[string]string `json:"responseHeaders,omitempty"`

		RetriesRemaining int32 `json:"retriesRemaining,omitempty"`

		RetryCount int32 `json:"retryCount,omitempty"`

		SocketContext *SocketContext `json:"socketContext,omitempty"`

		StatusCode int32 `json:"statusCode,omitempty"`

		Synchronize bool `json:"synchronize,omitempty"`

		SynchronizeOwner bool `json:"synchronizeOwner,omitempty"`

		SynchronizePeer bool `json:"synchronizePeer,omitempty"`

		TargetReplicated bool `json:"targetReplicated,omitempty"`

		TransactionID string `json:"transactionId,omitempty"`

		Update bool `json:"update,omitempty"`

		URI *URI `json:"uri,omitempty"`

		WithinTransaction bool `json:"withinTransaction,omitempty"`
	}{

		Action: m.Action,

		AuthorizationContext: m.AuthorizationContext,

		BodyRaw: m.BodyRaw,

		Commit: m.Commit,

		Completion: m.Completion,

		ConnectionSharing: m.ConnectionSharing,

		ConnectionTag: m.ConnectionTag,

		ContentLength: m.ContentLength,

		ContentType: m.ContentType,

		ContextID: m.ContextID,

		Cookies: m.Cookies,

		ErrorResponseBody: m.ErrorResponseBody,

		ExpirationMicrosUtc: m.ExpirationMicrosUtc,

		FailureLoggingDisabled: m.FailureLoggingDisabled,

		Forwarded: m.Forwarded,

		ForwardingDisabled: m.ForwardingDisabled,

		FromReplication: m.FromReplication,

		ID: m.ID,

		KeepAlive: m.KeepAlive,

		Notification: m.Notification,

		NotificationDisabled: m.NotificationDisabled,

		Options: m.Options,

		PeerCertificateChain: m.PeerCertificateChain,

		Referer: m.Referer,

		RefererAsString: m.RefererAsString,

		Remote: m.Remote,

		ReplicationDisabled: m.ReplicationDisabled,

		RequestHeaders: m.RequestHeaders,

		ResponseHeaders: m.ResponseHeaders,

		RetriesRemaining: m.RetriesRemaining,

		RetryCount: m.RetryCount,

		SocketContext: m.SocketContext,

		StatusCode: m.StatusCode,

		Synchronize: m.Synchronize,

		SynchronizeOwner: m.SynchronizeOwner,

		SynchronizePeer: m.SynchronizePeer,

		TargetReplicated: m.TargetReplicated,

		TransactionID: m.TransactionID,

		Update: m.Update,

		URI: m.URI,

		WithinTransaction: m.WithinTransaction,
	})
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		PeerPrincipal Principal `json:"peerPrincipal,omitempty"`
	}{

		PeerPrincipal: m.peerPrincipalField,
	})
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this operation
func (m *Operation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthorizationContext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorResponseBody(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePeerCertificateChain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePeerPrincipal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSocketContext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURI(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var operationTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GET","POST","PATCH","PUT","DELETE","OPTIONS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		operationTypeActionPropEnum = append(operationTypeActionPropEnum, v)
	}
}

const (

	// OperationActionGET captures enum value "GET"
	OperationActionGET string = "GET"

	// OperationActionPOST captures enum value "POST"
	OperationActionPOST string = "POST"

	// OperationActionPATCH captures enum value "PATCH"
	OperationActionPATCH string = "PATCH"

	// OperationActionPUT captures enum value "PUT"
	OperationActionPUT string = "PUT"

	// OperationActionDELETE captures enum value "DELETE"
	OperationActionDELETE string = "DELETE"

	// OperationActionOPTIONS captures enum value "OPTIONS"
	OperationActionOPTIONS string = "OPTIONS"
)

// prop value enum
func (m *Operation) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, operationTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Operation) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

func (m *Operation) validateAuthorizationContext(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthorizationContext) { // not required
		return nil
	}

	if m.AuthorizationContext != nil {
		if err := m.AuthorizationContext.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authorizationContext")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authorizationContext")
			}
			return err
		}
	}

	return nil
}

func (m *Operation) validateErrorResponseBody(formats strfmt.Registry) error {
	if swag.IsZero(m.ErrorResponseBody) { // not required
		return nil
	}

	if m.ErrorResponseBody != nil {
		if err := m.ErrorResponseBody.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("errorResponseBody")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("errorResponseBody")
			}
			return err
		}
	}

	return nil
}

var operationOptionsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CONNECTION_SHARING","KEEP_ALIVE","REPLICATED","FORWARDED","REPLICATION_DISABLED","CLONING_DISABLED","NOTIFICATION_DISABLED","REPLICATED_TARGET","FAILURE_LOGGING_DISABLED","REMOTE","RATE_LIMITED","SOCKET_ACTIVE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		operationOptionsItemsEnum = append(operationOptionsItemsEnum, v)
	}
}

func (m *Operation) validateOptionsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, operationOptionsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Operation) validateOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.Options) { // not required
		return nil
	}

	for i := 0; i < len(m.Options); i++ {

		// value enum
		if err := m.validateOptionsItemsEnum("options"+"."+strconv.Itoa(i), "body", m.Options[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *Operation) validatePeerCertificateChain(formats strfmt.Registry) error {
	if swag.IsZero(m.PeerCertificateChain) { // not required
		return nil
	}

	for i := 0; i < len(m.PeerCertificateChain); i++ {
		if swag.IsZero(m.PeerCertificateChain[i]) { // not required
			continue
		}

		if m.PeerCertificateChain[i] != nil {
			if err := m.PeerCertificateChain[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("peerCertificateChain" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("peerCertificateChain" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Operation) validatePeerPrincipal(formats strfmt.Registry) error {
	if swag.IsZero(m.PeerPrincipal()) { // not required
		return nil
	}

	if err := m.PeerPrincipal().Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("peerPrincipal")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("peerPrincipal")
		}
		return err
	}

	return nil
}

func (m *Operation) validateReferer(formats strfmt.Registry) error {
	if swag.IsZero(m.Referer) { // not required
		return nil
	}

	if m.Referer != nil {
		if err := m.Referer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("referer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("referer")
			}
			return err
		}
	}

	return nil
}

func (m *Operation) validateSocketContext(formats strfmt.Registry) error {
	if swag.IsZero(m.SocketContext) { // not required
		return nil
	}

	if m.SocketContext != nil {
		if err := m.SocketContext.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("socketContext")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("socketContext")
			}
			return err
		}
	}

	return nil
}

func (m *Operation) validateURI(formats strfmt.Registry) error {
	if swag.IsZero(m.URI) { // not required
		return nil
	}

	if m.URI != nil {
		if err := m.URI.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("uri")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("uri")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this operation based on the context it is used
func (m *Operation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuthorizationContext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateErrorResponseBody(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePeerCertificateChain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePeerPrincipal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReferer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSocketContext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateURI(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Operation) contextValidateAuthorizationContext(ctx context.Context, formats strfmt.Registry) error {

	if m.AuthorizationContext != nil {
		if err := m.AuthorizationContext.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authorizationContext")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authorizationContext")
			}
			return err
		}
	}

	return nil
}

func (m *Operation) contextValidateErrorResponseBody(ctx context.Context, formats strfmt.Registry) error {

	if m.ErrorResponseBody != nil {
		if err := m.ErrorResponseBody.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("errorResponseBody")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("errorResponseBody")
			}
			return err
		}
	}

	return nil
}

func (m *Operation) contextValidatePeerCertificateChain(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PeerCertificateChain); i++ {

		if m.PeerCertificateChain[i] != nil {
			if err := m.PeerCertificateChain[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("peerCertificateChain" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("peerCertificateChain" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Operation) contextValidatePeerPrincipal(ctx context.Context, formats strfmt.Registry) error {

	if err := m.PeerPrincipal().ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("peerPrincipal")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("peerPrincipal")
		}
		return err
	}

	return nil
}

func (m *Operation) contextValidateReferer(ctx context.Context, formats strfmt.Registry) error {

	if m.Referer != nil {
		if err := m.Referer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("referer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("referer")
			}
			return err
		}
	}

	return nil
}

func (m *Operation) contextValidateSocketContext(ctx context.Context, formats strfmt.Registry) error {

	if m.SocketContext != nil {
		if err := m.SocketContext.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("socketContext")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("socketContext")
			}
			return err
		}
	}

	return nil
}

func (m *Operation) contextValidateURI(ctx context.Context, formats strfmt.Registry) error {

	if m.URI != nil {
		if err := m.URI.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("uri")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("uri")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Operation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Operation) UnmarshalBinary(b []byte) error {
	var res Operation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
