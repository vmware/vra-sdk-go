// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"io/ioutil"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TileInfo TileInfo
//
// Contains information about a Tile.
//
// swagger:discriminator TileInfo Contains information about a Tile.
type TileInfo interface {
	runtime.Validatable
	runtime.ContextValidatable

	// Tile name.
	// Example: Kubernetes
	DisplayName() string
	SetDisplayName(string)

	// Task input properties.
	// Example: {"cloudProxyId":{"description":"","mandatory":false,"type":"String"},"fingerprint":{"description":"","mandatory":false,"type":"String"}}
	InputProperties() map[string]PropertyMetaData
	SetInputProperties(map[string]PropertyMetaData)

	// Task output properties.
	// Example: {"buildUrlId":{"description":"","mandatory":false,"type":"String"},"isFailed":{"description":"","mandatory":false,"type":"String"}}
	OutputProperties() map[string]PropertyMetaData
	SetOutputProperties(map[string]PropertyMetaData)

	// Unique Id associated with the tile.
	// Example: k8s
	TileID() string
	SetTileID(string)

	// AdditionalProperties in base type shoud be handled just like regular properties
	// At this moment, the base type property is pushed down to the subtype
}

type tileInfo struct {
	displayNameField string

	inputPropertiesField map[string]PropertyMetaData

	outputPropertiesField map[string]PropertyMetaData

	tileIdField string
}

// DisplayName gets the display name of this polymorphic type
func (m *tileInfo) DisplayName() string {
	return m.displayNameField
}

// SetDisplayName sets the display name of this polymorphic type
func (m *tileInfo) SetDisplayName(val string) {
	m.displayNameField = val
}

// InputProperties gets the input properties of this polymorphic type
func (m *tileInfo) InputProperties() map[string]PropertyMetaData {
	return m.inputPropertiesField
}

// SetInputProperties sets the input properties of this polymorphic type
func (m *tileInfo) SetInputProperties(val map[string]PropertyMetaData) {
	m.inputPropertiesField = val
}

// OutputProperties gets the output properties of this polymorphic type
func (m *tileInfo) OutputProperties() map[string]PropertyMetaData {
	return m.outputPropertiesField
}

// SetOutputProperties sets the output properties of this polymorphic type
func (m *tileInfo) SetOutputProperties(val map[string]PropertyMetaData) {
	m.outputPropertiesField = val
}

// TileID gets the tile Id of this polymorphic type
func (m *tileInfo) TileID() string {
	return m.tileIdField
}

// SetTileID sets the tile Id of this polymorphic type
func (m *tileInfo) SetTileID(val string) {
	m.tileIdField = val
}

// UnmarshalTileInfoSlice unmarshals polymorphic slices of TileInfo
func UnmarshalTileInfoSlice(reader io.Reader, consumer runtime.Consumer) ([]TileInfo, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []TileInfo
	for _, element := range elements {
		obj, err := unmarshalTileInfo(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalTileInfo unmarshals polymorphic TileInfo
func UnmarshalTileInfo(reader io.Reader, consumer runtime.Consumer) (TileInfo, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalTileInfo(data, consumer)
}

func unmarshalTileInfo(data []byte, consumer runtime.Consumer) (TileInfo, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the Contains information about a Tile. property.
	var getType struct {
		ContainsInformationAboutaTile string `json:"Contains information about a Tile."`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("Contains information about a Tile.", "body", getType.ContainsInformationAboutaTile); err != nil {
		return nil, err
	}

	// The value of Contains information about a Tile. is used to determine which type to create and unmarshal the data into
	switch getType.ContainsInformationAboutaTile {
	case "TileInfo":
		var result tileInfo
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	}
	return nil, errors.New(422, "invalid Contains information about a Tile. value: %q", getType.ContainsInformationAboutaTile)
}

// Validate validates this tile info
func (m *tileInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInputProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOutputProperties(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *tileInfo) validateInputProperties(formats strfmt.Registry) error {
	if swag.IsZero(m.InputProperties()) { // not required
		return nil
	}

	for k := range m.InputProperties() {

		if err := validate.Required("inputProperties"+"."+k, "body", m.InputProperties()[k]); err != nil {
			return err
		}
		if val, ok := m.InputProperties()[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inputProperties" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("inputProperties" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *tileInfo) validateOutputProperties(formats strfmt.Registry) error {
	if swag.IsZero(m.OutputProperties()) { // not required
		return nil
	}

	for k := range m.OutputProperties() {

		if err := validate.Required("outputProperties"+"."+k, "body", m.OutputProperties()[k]); err != nil {
			return err
		}
		if val, ok := m.OutputProperties()[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("outputProperties" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("outputProperties" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this tile info based on the context it is used
func (m *tileInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInputProperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOutputProperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *tileInfo) contextValidateInputProperties(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.InputProperties() {

		if val, ok := m.InputProperties()[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *tileInfo) contextValidateOutputProperties(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.OutputProperties() {

		if val, ok := m.OutputProperties()[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}
