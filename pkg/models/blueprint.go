// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Blueprint Blueprint
//
// swagger:model Blueprint
type Blueprint struct {

	// Blueprint YAML content
	Content string `json:"content,omitempty"`

	// Content source id
	// Read Only: true
	ContentSourceID string `json:"contentSourceId,omitempty"`

	// Content source path
	// Read Only: true
	ContentSourcePath string `json:"contentSourcePath,omitempty"`

	// Content source last sync time
	// Read Only: true
	// Format: date-time
	ContentSourceSyncAt strfmt.DateTime `json:"contentSourceSyncAt,omitempty"`

	// Content source last sync messages
	// Read Only: true
	ContentSourceSyncMessages []string `json:"contentSourceSyncMessages"`

	// Content source last sync status
	// Read Only: true
	// Enum: [SUCCESSFUL FAILED]
	ContentSourceSyncStatus string `json:"contentSourceSyncStatus,omitempty"`

	// Content source type
	// Read Only: true
	ContentSourceType string `json:"contentSourceType,omitempty"`

	// Created time
	// Read Only: true
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"createdAt,omitempty"`

	// Created by
	// Read Only: true
	CreatedBy string `json:"createdBy,omitempty"`

	// Blueprint description
	Description string `json:"description,omitempty"`

	// Object ID
	// Read Only: true
	ID string `json:"id,omitempty"`

	// Blueprint name
	Name string `json:"name,omitempty"`

	// Org ID
	// Read Only: true
	OrgID string `json:"orgId,omitempty"`

	// Project ID
	ProjectID string `json:"projectId,omitempty"`

	// Project Name
	// Read Only: true
	ProjectName string `json:"projectName,omitempty"`

	// Flag to indicate blueprint can be requested from any project in org
	RequestScopeOrg bool `json:"requestScopeOrg,omitempty"`

	// Blueprint self link
	// Read Only: true
	SelfLink string `json:"selfLink,omitempty"`

	// Blueprint status
	// Read Only: true
	// Enum: [DRAFT VERSIONED RELEASED]
	Status string `json:"status,omitempty"`

	// Total released versions
	// Read Only: true
	TotalReleasedVersions int32 `json:"totalReleasedVersions,omitempty"`

	// Total versions
	// Read Only: true
	TotalVersions int32 `json:"totalVersions,omitempty"`

	// Updated time
	// Read Only: true
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updatedAt,omitempty"`

	// Updated by
	// Read Only: true
	UpdatedBy string `json:"updatedBy,omitempty"`

	// Validation result on update
	// Read Only: true
	Valid *bool `json:"valid,omitempty"`

	// Validation messages
	// Read Only: true
	ValidationMessages []*BlueprintValidationMessage `json:"validationMessages"`
}

// Validate validates this blueprint
func (m *Blueprint) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContentSourceSyncAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContentSourceSyncStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationMessages(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Blueprint) validateContentSourceSyncAt(formats strfmt.Registry) error {
	if swag.IsZero(m.ContentSourceSyncAt) { // not required
		return nil
	}

	if err := validate.FormatOf("contentSourceSyncAt", "body", "date-time", m.ContentSourceSyncAt.String(), formats); err != nil {
		return err
	}

	return nil
}

var blueprintTypeContentSourceSyncStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SUCCESSFUL","FAILED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		blueprintTypeContentSourceSyncStatusPropEnum = append(blueprintTypeContentSourceSyncStatusPropEnum, v)
	}
}

const (

	// BlueprintContentSourceSyncStatusSUCCESSFUL captures enum value "SUCCESSFUL"
	BlueprintContentSourceSyncStatusSUCCESSFUL string = "SUCCESSFUL"

	// BlueprintContentSourceSyncStatusFAILED captures enum value "FAILED"
	BlueprintContentSourceSyncStatusFAILED string = "FAILED"
)

// prop value enum
func (m *Blueprint) validateContentSourceSyncStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, blueprintTypeContentSourceSyncStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Blueprint) validateContentSourceSyncStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.ContentSourceSyncStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateContentSourceSyncStatusEnum("contentSourceSyncStatus", "body", m.ContentSourceSyncStatus); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("createdAt", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

var blueprintTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DRAFT","VERSIONED","RELEASED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		blueprintTypeStatusPropEnum = append(blueprintTypeStatusPropEnum, v)
	}
}

const (

	// BlueprintStatusDRAFT captures enum value "DRAFT"
	BlueprintStatusDRAFT string = "DRAFT"

	// BlueprintStatusVERSIONED captures enum value "VERSIONED"
	BlueprintStatusVERSIONED string = "VERSIONED"

	// BlueprintStatusRELEASED captures enum value "RELEASED"
	BlueprintStatusRELEASED string = "RELEASED"
)

// prop value enum
func (m *Blueprint) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, blueprintTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Blueprint) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updatedAt", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) validateValidationMessages(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidationMessages) { // not required
		return nil
	}

	for i := 0; i < len(m.ValidationMessages); i++ {
		if swag.IsZero(m.ValidationMessages[i]) { // not required
			continue
		}

		if m.ValidationMessages[i] != nil {
			if err := m.ValidationMessages[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validationMessages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validationMessages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this blueprint based on the context it is used
func (m *Blueprint) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContentSourceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContentSourcePath(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContentSourceSyncAt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContentSourceSyncMessages(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContentSourceSyncStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContentSourceType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedAt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrgID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProjectName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfLink(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotalReleasedVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotalVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdatedAt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdatedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValid(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidationMessages(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Blueprint) contextValidateContentSourceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "contentSourceId", "body", string(m.ContentSourceID)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateContentSourcePath(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "contentSourcePath", "body", string(m.ContentSourcePath)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateContentSourceSyncAt(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "contentSourceSyncAt", "body", strfmt.DateTime(m.ContentSourceSyncAt)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateContentSourceSyncMessages(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "contentSourceSyncMessages", "body", []string(m.ContentSourceSyncMessages)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateContentSourceSyncStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "contentSourceSyncStatus", "body", string(m.ContentSourceSyncStatus)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateContentSourceType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "contentSourceType", "body", string(m.ContentSourceType)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateCreatedAt(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdAt", "body", strfmt.DateTime(m.CreatedAt)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateCreatedBy(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdBy", "body", string(m.CreatedBy)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateOrgID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "orgId", "body", string(m.OrgID)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateProjectName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "projectName", "body", string(m.ProjectName)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateSelfLink(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "selfLink", "body", string(m.SelfLink)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateTotalReleasedVersions(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "totalReleasedVersions", "body", int32(m.TotalReleasedVersions)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateTotalVersions(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "totalVersions", "body", int32(m.TotalVersions)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateUpdatedAt(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updatedAt", "body", strfmt.DateTime(m.UpdatedAt)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateUpdatedBy(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updatedBy", "body", string(m.UpdatedBy)); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateValid(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "valid", "body", m.Valid); err != nil {
		return err
	}

	return nil
}

func (m *Blueprint) contextValidateValidationMessages(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "validationMessages", "body", []*BlueprintValidationMessage(m.ValidationMessages)); err != nil {
		return err
	}

	for i := 0; i < len(m.ValidationMessages); i++ {

		if m.ValidationMessages[i] != nil {
			if err := m.ValidationMessages[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validationMessages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validationMessages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Blueprint) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Blueprint) UnmarshalBinary(b []byte) error {
	var res Blueprint
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
