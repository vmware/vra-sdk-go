// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"io/ioutil"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// VariableSpec VariableSpec
//
// A Variable is used to store re-usable/sensitive strings within Code Stream in an encrypted format so as to be able to consume in other areas like Endpoint, Pipeline, Task or Stage etc.
//
// swagger:discriminator VariableSpec A Variable is used to store re-usable/sensitive strings within Code Stream in an encrypted format so as to be able to consume in other areas like Endpoint, Pipeline, Task or Stage etc.
type VariableSpec interface {
	runtime.Validatable
	runtime.ContextValidatable

	// A human-friendly description.
	// Required: true
	Description() *string
	SetDescription(*string)

	// A human-friendly name used as an identifier in APIs that support this option
	// Example: My-Name
	// Required: true
	Name() *string
	SetName(*string)

	// The project this entity belongs to.
	// Example: My-Project
	Project() string
	SetProject(string)

	// The type of this Variable. Ex: REGULAR / SECRET / RESTRICTED
	// Example: REGULAR
	// Required: true
	Type() *string
	SetType(*string)

	// The value for this Variable.
	// Example: my-value
	// Required: true
	Value() *string
	SetValue(*string)

	// AdditionalProperties in base type shoud be handled just like regular properties
	// At this moment, the base type property is pushed down to the subtype
}

type variableSpec struct {
	descriptionField *string

	nameField *string

	projectField string

	typeField *string

	valueField *string
}

// Description gets the description of this polymorphic type
func (m *variableSpec) Description() *string {
	return m.descriptionField
}

// SetDescription sets the description of this polymorphic type
func (m *variableSpec) SetDescription(val *string) {
	m.descriptionField = val
}

// Name gets the name of this polymorphic type
func (m *variableSpec) Name() *string {
	return m.nameField
}

// SetName sets the name of this polymorphic type
func (m *variableSpec) SetName(val *string) {
	m.nameField = val
}

// Project gets the project of this polymorphic type
func (m *variableSpec) Project() string {
	return m.projectField
}

// SetProject sets the project of this polymorphic type
func (m *variableSpec) SetProject(val string) {
	m.projectField = val
}

// Type gets the type of this polymorphic type
func (m *variableSpec) Type() *string {
	return m.typeField
}

// SetType sets the type of this polymorphic type
func (m *variableSpec) SetType(val *string) {
	m.typeField = val
}

// Value gets the value of this polymorphic type
func (m *variableSpec) Value() *string {
	return m.valueField
}

// SetValue sets the value of this polymorphic type
func (m *variableSpec) SetValue(val *string) {
	m.valueField = val
}

// UnmarshalVariableSpecSlice unmarshals polymorphic slices of VariableSpec
func UnmarshalVariableSpecSlice(reader io.Reader, consumer runtime.Consumer) ([]VariableSpec, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []VariableSpec
	for _, element := range elements {
		obj, err := unmarshalVariableSpec(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalVariableSpec unmarshals polymorphic VariableSpec
func UnmarshalVariableSpec(reader io.Reader, consumer runtime.Consumer) (VariableSpec, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalVariableSpec(data, consumer)
}

func unmarshalVariableSpec(data []byte, consumer runtime.Consumer) (VariableSpec, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the A Variable is used to store re-usable/sensitive strings within Code Stream in an encrypted format so as to be able to consume in other areas like Endpoint, Pipeline, Task or Stage etc. property.
	var getType struct {
		AVariableIsUsedToStoreReUsableSensitiveStringsWithinCodeStreamInAnEncryptedFormatSoAsToBeAbleToConsumeInOtherAreasLikeEndpointPipelineTaskOrStageEtc string `json:"A Variable is used to store re-usable/sensitive strings within Code Stream in an encrypted format so as to be able to consume in other areas like Endpoint, Pipeline, Task or Stage etc."`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("A Variable is used to store re-usable/sensitive strings within Code Stream in an encrypted format so as to be able to consume in other areas like Endpoint, Pipeline, Task or Stage etc.", "body", getType.AVariableIsUsedToStoreReUsableSensitiveStringsWithinCodeStreamInAnEncryptedFormatSoAsToBeAbleToConsumeInOtherAreasLikeEndpointPipelineTaskOrStageEtc); err != nil {
		return nil, err
	}

	// The value of A Variable is used to store re-usable/sensitive strings within Code Stream in an encrypted format so as to be able to consume in other areas like Endpoint, Pipeline, Task or Stage etc. is used to determine which type to create and unmarshal the data into
	switch getType.AVariableIsUsedToStoreReUsableSensitiveStringsWithinCodeStreamInAnEncryptedFormatSoAsToBeAbleToConsumeInOtherAreasLikeEndpointPipelineTaskOrStageEtc {
	case "VariableSpec":
		var result variableSpec
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	}
	return nil, errors.New(422, "invalid A Variable is used to store re-usable/sensitive strings within Code Stream in an encrypted format so as to be able to consume in other areas like Endpoint, Pipeline, Task or Stage etc. value: %q", getType.AVariableIsUsedToStoreReUsableSensitiveStringsWithinCodeStreamInAnEncryptedFormatSoAsToBeAbleToConsumeInOtherAreasLikeEndpointPipelineTaskOrStageEtc)
}

// Validate validates this variable spec
func (m *variableSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *variableSpec) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description()); err != nil {
		return err
	}

	return nil
}

func (m *variableSpec) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name()); err != nil {
		return err
	}

	return nil
}

func (m *variableSpec) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type()); err != nil {
		return err
	}

	return nil
}

func (m *variableSpec) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("value", "body", m.Value()); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this variable spec based on context it is used
func (m *variableSpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}
