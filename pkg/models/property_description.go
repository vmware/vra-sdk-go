// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PropertyDescription property description
// swagger:model PropertyDescription
type PropertyDescription struct {

	// element description
	ElementDescription *PropertyDescription `json:"elementDescription,omitempty"`

	// enum values
	EnumValues []string `json:"enumValues"`

	// example value
	ExampleValue interface{} `json:"exampleValue,omitempty"`

	// field descriptions
	FieldDescriptions map[string]PropertyDescription `json:"fieldDescriptions,omitempty"`

	// indexing options
	IndexingOptions []string `json:"indexingOptions"`

	// is primitive
	IsPrimitive bool `json:"isPrimitive,omitempty"`

	// kind
	Kind string `json:"kind,omitempty"`

	// property documentation
	PropertyDocumentation string `json:"propertyDocumentation,omitempty"`

	// type name
	// Enum: [LONG STRING BYTES PODO COLLECTION MAP BOOLEAN DOUBLE InternetAddressV4 InternetAddressV6 DATE URI ENUM]
	TypeName string `json:"typeName,omitempty"`

	// usage options
	UsageOptions []string `json:"usageOptions"`
}

// Validate validates this property description
func (m *PropertyDescription) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateElementDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFieldDescriptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexingOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypeName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsageOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PropertyDescription) validateElementDescription(formats strfmt.Registry) error {

	if swag.IsZero(m.ElementDescription) { // not required
		return nil
	}

	if m.ElementDescription != nil {
		if err := m.ElementDescription.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("elementDescription")
			}
			return err
		}
	}

	return nil
}

func (m *PropertyDescription) validateFieldDescriptions(formats strfmt.Registry) error {

	if swag.IsZero(m.FieldDescriptions) { // not required
		return nil
	}

	for k := range m.FieldDescriptions {

		if err := validate.Required("fieldDescriptions"+"."+k, "body", m.FieldDescriptions[k]); err != nil {
			return err
		}
		if val, ok := m.FieldDescriptions[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

var propertyDescriptionIndexingOptionsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["EXPAND","FIXED_ITEM_NAME","STORE_ONLY","TEXT","CASE_INSENSITIVE","EXCLUDE_FROM_SIGNATURE","SORT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		propertyDescriptionIndexingOptionsItemsEnum = append(propertyDescriptionIndexingOptionsItemsEnum, v)
	}
}

func (m *PropertyDescription) validateIndexingOptionsItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, propertyDescriptionIndexingOptionsItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *PropertyDescription) validateIndexingOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.IndexingOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.IndexingOptions); i++ {

		// value enum
		if err := m.validateIndexingOptionsItemsEnum("indexingOptions"+"."+strconv.Itoa(i), "body", m.IndexingOptions[i]); err != nil {
			return err
		}

	}

	return nil
}

var propertyDescriptionTypeTypeNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LONG","STRING","BYTES","PODO","COLLECTION","MAP","BOOLEAN","DOUBLE","InternetAddressV4","InternetAddressV6","DATE","URI","ENUM"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		propertyDescriptionTypeTypeNamePropEnum = append(propertyDescriptionTypeTypeNamePropEnum, v)
	}
}

const (

	// PropertyDescriptionTypeNameLONG captures enum value "LONG"
	PropertyDescriptionTypeNameLONG string = "LONG"

	// PropertyDescriptionTypeNameSTRING captures enum value "STRING"
	PropertyDescriptionTypeNameSTRING string = "STRING"

	// PropertyDescriptionTypeNameBYTES captures enum value "BYTES"
	PropertyDescriptionTypeNameBYTES string = "BYTES"

	// PropertyDescriptionTypeNamePODO captures enum value "PODO"
	PropertyDescriptionTypeNamePODO string = "PODO"

	// PropertyDescriptionTypeNameCOLLECTION captures enum value "COLLECTION"
	PropertyDescriptionTypeNameCOLLECTION string = "COLLECTION"

	// PropertyDescriptionTypeNameMAP captures enum value "MAP"
	PropertyDescriptionTypeNameMAP string = "MAP"

	// PropertyDescriptionTypeNameBOOLEAN captures enum value "BOOLEAN"
	PropertyDescriptionTypeNameBOOLEAN string = "BOOLEAN"

	// PropertyDescriptionTypeNameDOUBLE captures enum value "DOUBLE"
	PropertyDescriptionTypeNameDOUBLE string = "DOUBLE"

	// PropertyDescriptionTypeNameInternetAddressV4 captures enum value "InternetAddressV4"
	PropertyDescriptionTypeNameInternetAddressV4 string = "InternetAddressV4"

	// PropertyDescriptionTypeNameInternetAddressV6 captures enum value "InternetAddressV6"
	PropertyDescriptionTypeNameInternetAddressV6 string = "InternetAddressV6"

	// PropertyDescriptionTypeNameDATE captures enum value "DATE"
	PropertyDescriptionTypeNameDATE string = "DATE"

	// PropertyDescriptionTypeNameURI captures enum value "URI"
	PropertyDescriptionTypeNameURI string = "URI"

	// PropertyDescriptionTypeNameENUM captures enum value "ENUM"
	PropertyDescriptionTypeNameENUM string = "ENUM"
)

// prop value enum
func (m *PropertyDescription) validateTypeNameEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, propertyDescriptionTypeTypeNamePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *PropertyDescription) validateTypeName(formats strfmt.Registry) error {

	if swag.IsZero(m.TypeName) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeNameEnum("typeName", "body", m.TypeName); err != nil {
		return err
	}

	return nil
}

var propertyDescriptionUsageOptionsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SINGLE_ASSIGNMENT","OPTIONAL","SERVICE_USE","INFRASTRUCTURE","AUTO_MERGE_IF_NOT_NULL","ID","LINK","LINKS","SENSITIVE","REQUIRED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		propertyDescriptionUsageOptionsItemsEnum = append(propertyDescriptionUsageOptionsItemsEnum, v)
	}
}

func (m *PropertyDescription) validateUsageOptionsItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, propertyDescriptionUsageOptionsItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *PropertyDescription) validateUsageOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.UsageOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.UsageOptions); i++ {

		// value enum
		if err := m.validateUsageOptionsItemsEnum("usageOptions"+"."+strconv.Itoa(i), "body", m.UsageOptions[i]); err != nil {
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PropertyDescription) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PropertyDescription) UnmarshalBinary(b []byte) error {
	var res PropertyDescription
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
