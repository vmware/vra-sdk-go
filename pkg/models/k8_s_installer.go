// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// K8SInstaller K8SInstaller
//
// swagger:model K8SInstaller
type K8SInstaller struct {

	// cluster Id
	ClusterID string `json:"clusterId,omitempty"`

	// cluster Id old
	// Format: uuid
	ClusterIDOld strfmt.UUID `json:"clusterIdOld,omitempty"`

	// content
	Content string `json:"content,omitempty"`

	// created millis
	CreatedMillis int64 `json:"createdMillis,omitempty"`

	// custom resources
	CustomResources map[string]string `json:"customResources,omitempty"`

	// id
	// Format: uuid
	ID strfmt.UUID `json:"id,omitempty"`

	// installation parameters
	InstallationParameters map[string]string `json:"installationParameters,omitempty"`

	// installer type
	// Enum: [CLUSTER NAMESPACE SUPERVISOR_CLUSTER SUPERVISOR_NAMESPACE]
	InstallerType string `json:"installerType,omitempty"`

	// org Id
	OrgID string `json:"orgId,omitempty"`

	// owner Id
	OwnerID string `json:"ownerId,omitempty"`

	// owner Id old
	// Format: uuid
	OwnerIDOld strfmt.UUID `json:"ownerIdOld,omitempty"`

	// retry count
	RetryCount int32 `json:"retryCount,omitempty"`

	// rollback on fail
	RollbackOnFail bool `json:"rollbackOnFail,omitempty"`

	// state
	// Enum: [CREATED INSTALLING NOT_READY READY UNINSTALLING UNINSTALLED FAILED DELETING]
	State string `json:"state,omitempty"`

	// steps
	Steps []*K8SResource `json:"steps"`

	// updated millis
	UpdatedMillis int64 `json:"updatedMillis,omitempty"`
}

// Validate validates this k8 s installer
func (m *K8SInstaller) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClusterIDOld(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstallerType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwnerIDOld(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSteps(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *K8SInstaller) validateClusterIDOld(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterIDOld) { // not required
		return nil
	}

	if err := validate.FormatOf("clusterIdOld", "body", "uuid", m.ClusterIDOld.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *K8SInstaller) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

var k8SInstallerTypeInstallerTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CLUSTER","NAMESPACE","SUPERVISOR_CLUSTER","SUPERVISOR_NAMESPACE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		k8SInstallerTypeInstallerTypePropEnum = append(k8SInstallerTypeInstallerTypePropEnum, v)
	}
}

const (

	// K8SInstallerInstallerTypeCLUSTER captures enum value "CLUSTER"
	K8SInstallerInstallerTypeCLUSTER string = "CLUSTER"

	// K8SInstallerInstallerTypeNAMESPACE captures enum value "NAMESPACE"
	K8SInstallerInstallerTypeNAMESPACE string = "NAMESPACE"

	// K8SInstallerInstallerTypeSUPERVISORCLUSTER captures enum value "SUPERVISOR_CLUSTER"
	K8SInstallerInstallerTypeSUPERVISORCLUSTER string = "SUPERVISOR_CLUSTER"

	// K8SInstallerInstallerTypeSUPERVISORNAMESPACE captures enum value "SUPERVISOR_NAMESPACE"
	K8SInstallerInstallerTypeSUPERVISORNAMESPACE string = "SUPERVISOR_NAMESPACE"
)

// prop value enum
func (m *K8SInstaller) validateInstallerTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, k8SInstallerTypeInstallerTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *K8SInstaller) validateInstallerType(formats strfmt.Registry) error {
	if swag.IsZero(m.InstallerType) { // not required
		return nil
	}

	// value enum
	if err := m.validateInstallerTypeEnum("installerType", "body", m.InstallerType); err != nil {
		return err
	}

	return nil
}

func (m *K8SInstaller) validateOwnerIDOld(formats strfmt.Registry) error {
	if swag.IsZero(m.OwnerIDOld) { // not required
		return nil
	}

	if err := validate.FormatOf("ownerIdOld", "body", "uuid", m.OwnerIDOld.String(), formats); err != nil {
		return err
	}

	return nil
}

var k8SInstallerTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CREATED","INSTALLING","NOT_READY","READY","UNINSTALLING","UNINSTALLED","FAILED","DELETING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		k8SInstallerTypeStatePropEnum = append(k8SInstallerTypeStatePropEnum, v)
	}
}

const (

	// K8SInstallerStateCREATED captures enum value "CREATED"
	K8SInstallerStateCREATED string = "CREATED"

	// K8SInstallerStateINSTALLING captures enum value "INSTALLING"
	K8SInstallerStateINSTALLING string = "INSTALLING"

	// K8SInstallerStateNOTREADY captures enum value "NOT_READY"
	K8SInstallerStateNOTREADY string = "NOT_READY"

	// K8SInstallerStateREADY captures enum value "READY"
	K8SInstallerStateREADY string = "READY"

	// K8SInstallerStateUNINSTALLING captures enum value "UNINSTALLING"
	K8SInstallerStateUNINSTALLING string = "UNINSTALLING"

	// K8SInstallerStateUNINSTALLED captures enum value "UNINSTALLED"
	K8SInstallerStateUNINSTALLED string = "UNINSTALLED"

	// K8SInstallerStateFAILED captures enum value "FAILED"
	K8SInstallerStateFAILED string = "FAILED"

	// K8SInstallerStateDELETING captures enum value "DELETING"
	K8SInstallerStateDELETING string = "DELETING"
)

// prop value enum
func (m *K8SInstaller) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, k8SInstallerTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *K8SInstaller) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *K8SInstaller) validateSteps(formats strfmt.Registry) error {
	if swag.IsZero(m.Steps) { // not required
		return nil
	}

	for i := 0; i < len(m.Steps); i++ {
		if swag.IsZero(m.Steps[i]) { // not required
			continue
		}

		if m.Steps[i] != nil {
			if err := m.Steps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("steps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("steps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this k8 s installer based on the context it is used
func (m *K8SInstaller) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSteps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *K8SInstaller) contextValidateSteps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Steps); i++ {

		if m.Steps[i] != nil {
			if err := m.Steps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("steps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("steps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *K8SInstaller) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *K8SInstaller) UnmarshalBinary(b []byte) error {
	var res K8SInstaller
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
