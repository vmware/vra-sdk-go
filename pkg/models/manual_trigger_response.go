// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// ManualTriggerResponse ManualTriggerResponse
//
// Gerrit Manual Trigger response acknowledges the success or failure and in case of success, it lists the the pipelines which got triggered.
//
// swagger:discriminator ManualTriggerResponse Gerrit Manual Trigger response acknowledges the success or failure and in case of success, it lists the the pipelines which got triggered.
type ManualTriggerResponse interface {
	runtime.Validatable
	runtime.ContextValidatable

	// Message to acknowledge success or failure of action.
	// Example: Manual Trigger Successful
	Message() string
	SetMessage(string)

	// List of pipeline which got manually triggered.
	// Example: ["Pipeline-1","Pipeline-2"]
	PipelinesTriggered() []string
	SetPipelinesTriggered([]string)

	// AdditionalProperties in base type shoud be handled just like regular properties
	// At this moment, the base type property is pushed down to the subtype
}

type manualTriggerResponse struct {
	messageField string

	pipelinesTriggeredField []string
}

// Message gets the message of this polymorphic type
func (m *manualTriggerResponse) Message() string {
	return m.messageField
}

// SetMessage sets the message of this polymorphic type
func (m *manualTriggerResponse) SetMessage(val string) {
	m.messageField = val
}

// PipelinesTriggered gets the pipelines triggered of this polymorphic type
func (m *manualTriggerResponse) PipelinesTriggered() []string {
	return m.pipelinesTriggeredField
}

// SetPipelinesTriggered sets the pipelines triggered of this polymorphic type
func (m *manualTriggerResponse) SetPipelinesTriggered(val []string) {
	m.pipelinesTriggeredField = val
}

// UnmarshalManualTriggerResponseSlice unmarshals polymorphic slices of ManualTriggerResponse
func UnmarshalManualTriggerResponseSlice(reader io.Reader, consumer runtime.Consumer) ([]ManualTriggerResponse, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []ManualTriggerResponse
	for _, element := range elements {
		obj, err := unmarshalManualTriggerResponse(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalManualTriggerResponse unmarshals polymorphic ManualTriggerResponse
func UnmarshalManualTriggerResponse(reader io.Reader, consumer runtime.Consumer) (ManualTriggerResponse, error) {
	// we need to read this twice, so first into a buffer
	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalManualTriggerResponse(data, consumer)
}

func unmarshalManualTriggerResponse(data []byte, consumer runtime.Consumer) (ManualTriggerResponse, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the Gerrit Manual Trigger response acknowledges the success or failure and in case of success, it lists the the pipelines which got triggered. property.
	var getType struct {
		GerritManualTriggerResponseAcknowledgesTheSuccessOrFailureAndInCaseOfSuccessItListsTheThePipelinesWhichGotTriggered string `json:"Gerrit Manual Trigger response acknowledges the success or failure and in case of success, it lists the the pipelines which got triggered."`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("Gerrit Manual Trigger response acknowledges the success or failure and in case of success, it lists the the pipelines which got triggered.", "body", getType.GerritManualTriggerResponseAcknowledgesTheSuccessOrFailureAndInCaseOfSuccessItListsTheThePipelinesWhichGotTriggered); err != nil {
		return nil, err
	}

	// The value of Gerrit Manual Trigger response acknowledges the success or failure and in case of success, it lists the the pipelines which got triggered. is used to determine which type to create and unmarshal the data into
	switch getType.GerritManualTriggerResponseAcknowledgesTheSuccessOrFailureAndInCaseOfSuccessItListsTheThePipelinesWhichGotTriggered {
	case "ManualTriggerResponse":
		var result manualTriggerResponse
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	}
	return nil, errors.New(422, "invalid Gerrit Manual Trigger response acknowledges the success or failure and in case of success, it lists the the pipelines which got triggered. value: %q", getType.GerritManualTriggerResponseAcknowledgesTheSuccessOrFailureAndInCaseOfSuccessItListsTheThePipelinesWhichGotTriggered)
}

// Validate validates this manual trigger response
func (m *manualTriggerResponse) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this manual trigger response based on context it is used
func (m *manualTriggerResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}
