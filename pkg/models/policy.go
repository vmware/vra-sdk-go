// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Policy Policy
//
// A policy such as lease policy that will be enforced.
//
// swagger:model Policy
type Policy struct {

	// Policy creation timestamp.
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"createdAt,omitempty"`

	// Policy author.
	CreatedBy string `json:"createdBy,omitempty"`

	// Policy-type-specific target object filter criteria applied during enforcement.
	Criteria *Criteria `json:"criteria,omitempty"`

	// Policy-type-specific settings such as lease limits for lease policies.
	Definition interface{} `json:"definition,omitempty"`

	// definition legend
	DefinitionLegend map[string]DataElement `json:"definitionLegend,omitempty"`

	// The policy description.
	Description string `json:"description,omitempty"`

	// Defines enforcement type for policy. Default enforcement type is HARD.
	// Enum: [SOFT HARD]
	EnforcementType string `json:"enforcementType,omitempty"`

	// The policy ID.
	// Format: uuid
	ID strfmt.UUID `json:"id,omitempty"`

	// Most recent policy update timestamp.
	// Format: date-time
	LastUpdatedAt strfmt.DateTime `json:"lastUpdatedAt,omitempty"`

	// Most recent policy editor.
	LastUpdatedBy string `json:"lastUpdatedBy,omitempty"`

	// The policy name.
	Name string `json:"name,omitempty"`

	// The ID of the organization to which the policy belongs.
	OrgID string `json:"orgId,omitempty"`

	// For project-scoped policies, the ID of the project to which the policy belongs.
	ProjectID string `json:"projectId,omitempty"`

	// Project-based scope criteria to apply policy to multiple projects in the organization. Not allowed for project-scoped policies.
	ScopeCriteria *Criteria `json:"scopeCriteria,omitempty"`

	// statistics
	Statistics *PolicyStats `json:"statistics,omitempty"`

	// The policy type ID.
	// Required: true
	TypeID *string `json:"typeId"`
}

// Validate validates this policy
func (m *Policy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCriteria(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefinitionLegend(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnforcementType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScopeCriteria(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypeID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Policy) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("createdAt", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Policy) validateCriteria(formats strfmt.Registry) error {
	if swag.IsZero(m.Criteria) { // not required
		return nil
	}

	if m.Criteria != nil {
		if err := m.Criteria.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("criteria")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("criteria")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validateDefinitionLegend(formats strfmt.Registry) error {
	if swag.IsZero(m.DefinitionLegend) { // not required
		return nil
	}

	for k := range m.DefinitionLegend {

		if err := validate.Required("definitionLegend"+"."+k, "body", m.DefinitionLegend[k]); err != nil {
			return err
		}
		if val, ok := m.DefinitionLegend[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("definitionLegend" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("definitionLegend" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

var policyTypeEnforcementTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SOFT","HARD"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyTypeEnforcementTypePropEnum = append(policyTypeEnforcementTypePropEnum, v)
	}
}

const (

	// PolicyEnforcementTypeSOFT captures enum value "SOFT"
	PolicyEnforcementTypeSOFT string = "SOFT"

	// PolicyEnforcementTypeHARD captures enum value "HARD"
	PolicyEnforcementTypeHARD string = "HARD"
)

// prop value enum
func (m *Policy) validateEnforcementTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyTypeEnforcementTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Policy) validateEnforcementType(formats strfmt.Registry) error {
	if swag.IsZero(m.EnforcementType) { // not required
		return nil
	}

	// value enum
	if err := m.validateEnforcementTypeEnum("enforcementType", "body", m.EnforcementType); err != nil {
		return err
	}

	return nil
}

func (m *Policy) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Policy) validateLastUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.LastUpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("lastUpdatedAt", "body", "date-time", m.LastUpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Policy) validateScopeCriteria(formats strfmt.Registry) error {
	if swag.IsZero(m.ScopeCriteria) { // not required
		return nil
	}

	if m.ScopeCriteria != nil {
		if err := m.ScopeCriteria.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scopeCriteria")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scopeCriteria")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validateTypeID(formats strfmt.Registry) error {

	if err := validate.Required("typeId", "body", m.TypeID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this policy based on the context it is used
func (m *Policy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCriteria(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefinitionLegend(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScopeCriteria(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Policy) contextValidateCriteria(ctx context.Context, formats strfmt.Registry) error {

	if m.Criteria != nil {
		if err := m.Criteria.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("criteria")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("criteria")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidateDefinitionLegend(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.DefinitionLegend {

		if val, ok := m.DefinitionLegend[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *Policy) contextValidateScopeCriteria(ctx context.Context, formats strfmt.Registry) error {

	if m.ScopeCriteria != nil {
		if err := m.ScopeCriteria.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scopeCriteria")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scopeCriteria")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Policy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Policy) UnmarshalBinary(b []byte) error {
	var res Policy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
