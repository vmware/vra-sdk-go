// Code generated by go-swagger; DO NOT EDIT.

package triggers

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new triggers API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for triggers API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CloneGerritListenerByNameUsingPOST(params *CloneGerritListenerByNameUsingPOSTParams, opts ...ClientOption) (*CloneGerritListenerByNameUsingPOSTOK, error)

	CloneGerritListenerUsingPOST(params *CloneGerritListenerUsingPOSTParams, opts ...ClientOption) (*CloneGerritListenerUsingPOSTOK, error)

	CloneGerritTriggerByNameUsingPOST(params *CloneGerritTriggerByNameUsingPOSTParams, opts ...ClientOption) (*CloneGerritTriggerByNameUsingPOSTOK, error)

	CloneGerritTriggerUsingPOST(params *CloneGerritTriggerUsingPOSTParams, opts ...ClientOption) (*CloneGerritTriggerUsingPOSTOK, error)

	CreateDockerRegistryWebhookUsingPOST(params *CreateDockerRegistryWebhookUsingPOSTParams, opts ...ClientOption) (*CreateDockerRegistryWebhookUsingPOSTOK, error)

	CreateGerritListenerUsingPOST(params *CreateGerritListenerUsingPOSTParams, opts ...ClientOption) (*CreateGerritListenerUsingPOSTOK, error)

	CreateGerritTriggerUsingPOST(params *CreateGerritTriggerUsingPOSTParams, opts ...ClientOption) (*CreateGerritTriggerUsingPOSTOK, error)

	CreateGitWebhookUsingPOST(params *CreateGitWebhookUsingPOSTParams, opts ...ClientOption) (*CreateGitWebhookUsingPOSTOK, error)

	DeleteDockerRegistryEventByIDUsingDELETE(params *DeleteDockerRegistryEventByIDUsingDELETEParams, opts ...ClientOption) (*DeleteDockerRegistryEventByIDUsingDELETEOK, error)

	DeleteDockerRegistryWebhookByIDUsingDELETE(params *DeleteDockerRegistryWebhookByIDUsingDELETEParams, opts ...ClientOption) (*DeleteDockerRegistryWebhookByIDUsingDELETEOK, error)

	DeleteDockerRegistryWebhookByNameUsingDELETE(params *DeleteDockerRegistryWebhookByNameUsingDELETEParams, opts ...ClientOption) (*DeleteDockerRegistryWebhookByNameUsingDELETEOK, error)

	DeleteGerritEventByIDUsingDELETE(params *DeleteGerritEventByIDUsingDELETEParams, opts ...ClientOption) (*DeleteGerritEventByIDUsingDELETEOK, error)

	DeleteGerritListenerByIDUsingDELETE(params *DeleteGerritListenerByIDUsingDELETEParams, opts ...ClientOption) (*DeleteGerritListenerByIDUsingDELETEOK, error)

	DeleteGerritListenerByNameUsingDELETE(params *DeleteGerritListenerByNameUsingDELETEParams, opts ...ClientOption) (*DeleteGerritListenerByNameUsingDELETEOK, error)

	DeleteGerritTriggerByIDUsingDELETE(params *DeleteGerritTriggerByIDUsingDELETEParams, opts ...ClientOption) (*DeleteGerritTriggerByIDUsingDELETEOK, error)

	DeleteGerritTriggerByNameUsingDELETE(params *DeleteGerritTriggerByNameUsingDELETEParams, opts ...ClientOption) (*DeleteGerritTriggerByNameUsingDELETEOK, error)

	DeleteGitEventsByIDUsingDELETE(params *DeleteGitEventsByIDUsingDELETEParams, opts ...ClientOption) (*DeleteGitEventsByIDUsingDELETEOK, error)

	DeleteGitWebhookByIDUsingDELETE(params *DeleteGitWebhookByIDUsingDELETEParams, opts ...ClientOption) (*DeleteGitWebhookByIDUsingDELETEOK, error)

	DeleteGitWebhookByNameUsingDELETE(params *DeleteGitWebhookByNameUsingDELETEParams, opts ...ClientOption) (*DeleteGitWebhookByNameUsingDELETEOK, error)

	GetAllDockerRegistryEventsUsingGET(params *GetAllDockerRegistryEventsUsingGETParams, opts ...ClientOption) (*GetAllDockerRegistryEventsUsingGETOK, error)

	GetAllDockerRegistryWebhooksUsingGET(params *GetAllDockerRegistryWebhooksUsingGETParams, opts ...ClientOption) (*GetAllDockerRegistryWebhooksUsingGETOK, error)

	GetAllGerritEventsUsingGET(params *GetAllGerritEventsUsingGETParams, opts ...ClientOption) (*GetAllGerritEventsUsingGETOK, error)

	GetAllGerritListenersUsingGET(params *GetAllGerritListenersUsingGETParams, opts ...ClientOption) (*GetAllGerritListenersUsingGETOK, error)

	GetAllGerritTriggersUsingGET(params *GetAllGerritTriggersUsingGETParams, opts ...ClientOption) (*GetAllGerritTriggersUsingGETOK, error)

	GetAllGitEventsUsingGET(params *GetAllGitEventsUsingGETParams, opts ...ClientOption) (*GetAllGitEventsUsingGETOK, error)

	GetAllGitWebhooksUsingGET(params *GetAllGitWebhooksUsingGETParams, opts ...ClientOption) (*GetAllGitWebhooksUsingGETOK, error)

	GetDockerRegistryWebhookNameUsingGET(params *GetDockerRegistryWebhookNameUsingGETParams, opts ...ClientOption) (*GetDockerRegistryWebhookNameUsingGETOK, error)

	GetGerritEventByIDUsingGET(params *GetGerritEventByIDUsingGETParams, opts ...ClientOption) (*GetGerritEventByIDUsingGETOK, error)

	GetGerritListenerByIDUsingGET(params *GetGerritListenerByIDUsingGETParams, opts ...ClientOption) (*GetGerritListenerByIDUsingGETOK, error)

	GetGerritListenerByNameUsingGET(params *GetGerritListenerByNameUsingGETParams, opts ...ClientOption) (*GetGerritListenerByNameUsingGETOK, error)

	GetGerritProjectsByIDUsingGET(params *GetGerritProjectsByIDUsingGETParams, opts ...ClientOption) (*GetGerritProjectsByIDUsingGETOK, error)

	GetGerritProjectsByNameUsingGET(params *GetGerritProjectsByNameUsingGETParams, opts ...ClientOption) (*GetGerritProjectsByNameUsingGETOK, error)

	GetGerritTriggerByIDUsingGET(params *GetGerritTriggerByIDUsingGETParams, opts ...ClientOption) (*GetGerritTriggerByIDUsingGETOK, error)

	GetGerritTriggerByNameUsingGET(params *GetGerritTriggerByNameUsingGETParams, opts ...ClientOption) (*GetGerritTriggerByNameUsingGETOK, error)

	GetGitEventByIDUsingGET(params *GetGitEventByIDUsingGETParams, opts ...ClientOption) (*GetGitEventByIDUsingGETOK, error)

	GetGitWebhookByIDUsingGET(params *GetGitWebhookByIDUsingGETParams, opts ...ClientOption) (*GetGitWebhookByIDUsingGETOK, error)

	GetGitWebhookByNameUsingGET(params *GetGitWebhookByNameUsingGETParams, opts ...ClientOption) (*GetGitWebhookByNameUsingGETOK, error)

	GetRegistryEventByID(params *GetRegistryEventByIDParams, opts ...ClientOption) (*GetRegistryEventByIDOK, error)

	GetRegistryWebhookByID(params *GetRegistryWebhookByIDParams, opts ...ClientOption) (*GetRegistryWebhookByIDOK, error)

	ManualGerritEventTriggerUsingPOST(params *ManualGerritEventTriggerUsingPOSTParams, opts ...ClientOption) (*ManualGerritEventTriggerUsingPOSTOK, error)

	PatchDockerRegistryWebhookByIDUsingPATCH(params *PatchDockerRegistryWebhookByIDUsingPATCHParams, opts ...ClientOption) (*PatchDockerRegistryWebhookByIDUsingPATCHOK, error)

	PatchDockerRegistryWebhookByNameUsingPATCH(params *PatchDockerRegistryWebhookByNameUsingPATCHParams, opts ...ClientOption) (*PatchDockerRegistryWebhookByNameUsingPATCHOK, error)

	PatchGerritListenerByIDUsingPATCH(params *PatchGerritListenerByIDUsingPATCHParams, opts ...ClientOption) (*PatchGerritListenerByIDUsingPATCHOK, error)

	PatchGerritListenerByNameUsingPATCH(params *PatchGerritListenerByNameUsingPATCHParams, opts ...ClientOption) (*PatchGerritListenerByNameUsingPATCHOK, error)

	PatchGerritTriggerByIDUsingPATCH(params *PatchGerritTriggerByIDUsingPATCHParams, opts ...ClientOption) (*PatchGerritTriggerByIDUsingPATCHOK, error)

	PatchGerritTriggerByNameUsingPATCH(params *PatchGerritTriggerByNameUsingPATCHParams, opts ...ClientOption) (*PatchGerritTriggerByNameUsingPATCHOK, error)

	ResumeOrRerunDockerRegistryEventUsingPOST(params *ResumeOrRerunDockerRegistryEventUsingPOSTParams, opts ...ClientOption) (*ResumeOrRerunDockerRegistryEventUsingPOSTOK, error)

	ResumeOrRerunGerritEventUsingPOST(params *ResumeOrRerunGerritEventUsingPOSTParams, opts ...ClientOption) (*ResumeOrRerunGerritEventUsingPOSTOK, error)

	ResumeOrRerunGitEventUsingPOST(params *ResumeOrRerunGitEventUsingPOSTParams, opts ...ClientOption) (*ResumeOrRerunGitEventUsingPOSTOK, error)

	UpdateDockerRegistryWebhookByIDUsingPUT(params *UpdateDockerRegistryWebhookByIDUsingPUTParams, opts ...ClientOption) (*UpdateDockerRegistryWebhookByIDUsingPUTOK, error)

	UpdateDockerRegistryWebhookByNameUsingPUT(params *UpdateDockerRegistryWebhookByNameUsingPUTParams, opts ...ClientOption) (*UpdateDockerRegistryWebhookByNameUsingPUTOK, error)

	UpdateGerritListenerByIDUsingPUT(params *UpdateGerritListenerByIDUsingPUTParams, opts ...ClientOption) (*UpdateGerritListenerByIDUsingPUTOK, error)

	UpdateGerritListenerByNameUsingPUT(params *UpdateGerritListenerByNameUsingPUTParams, opts ...ClientOption) (*UpdateGerritListenerByNameUsingPUTOK, error)

	UpdateGerritTriggerByIDUsingPUT(params *UpdateGerritTriggerByIDUsingPUTParams, opts ...ClientOption) (*UpdateGerritTriggerByIDUsingPUTOK, error)

	UpdateGerritTriggerByNameUsingPUT(params *UpdateGerritTriggerByNameUsingPUTParams, opts ...ClientOption) (*UpdateGerritTriggerByNameUsingPUTOK, error)

	UpdateGitWebhookByIDUsingPUT(params *UpdateGitWebhookByIDUsingPUTParams, opts ...ClientOption) (*UpdateGitWebhookByIDUsingPUTOK, error)

	UpdateGitWebhookByNameUsingPUT(params *UpdateGitWebhookByNameUsingPUTParams, opts ...ClientOption) (*UpdateGitWebhookByNameUsingPUTOK, error)

	ValidateGerritListenerUsingPOST(params *ValidateGerritListenerUsingPOSTParams, opts ...ClientOption) (*ValidateGerritListenerUsingPOSTOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  CloneGerritListenerByNameUsingPOST clones a gerrit listener by project and name

  Clone a Gerrit Listener with the given project and name
*/
func (a *Client) CloneGerritListenerByNameUsingPOST(params *CloneGerritListenerByNameUsingPOSTParams, opts ...ClientOption) (*CloneGerritListenerByNameUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloneGerritListenerByNameUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cloneGerritListenerByNameUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/gerrit-listeners/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CloneGerritListenerByNameUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CloneGerritListenerByNameUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cloneGerritListenerByNameUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CloneGerritListenerUsingPOST clones a gerrit listener

  Clone a Gerrit Listener
*/
func (a *Client) CloneGerritListenerUsingPOST(params *CloneGerritListenerUsingPOSTParams, opts ...ClientOption) (*CloneGerritListenerUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloneGerritListenerUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cloneGerritListenerUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/gerrit-listeners/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CloneGerritListenerUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CloneGerritListenerUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cloneGerritListenerUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CloneGerritTriggerByNameUsingPOST clones a gerrit trigger by project and name

  Clone a Gerrit Trigger with the given project and name
*/
func (a *Client) CloneGerritTriggerByNameUsingPOST(params *CloneGerritTriggerByNameUsingPOSTParams, opts ...ClientOption) (*CloneGerritTriggerByNameUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloneGerritTriggerByNameUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cloneGerritTriggerByNameUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/gerrit-triggers/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CloneGerritTriggerByNameUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CloneGerritTriggerByNameUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cloneGerritTriggerByNameUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CloneGerritTriggerUsingPOST clones a gerrit trigger

  Clone a Gerrit Trigger
*/
func (a *Client) CloneGerritTriggerUsingPOST(params *CloneGerritTriggerUsingPOSTParams, opts ...ClientOption) (*CloneGerritTriggerUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloneGerritTriggerUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "cloneGerritTriggerUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/gerrit-triggers/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CloneGerritTriggerUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CloneGerritTriggerUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cloneGerritTriggerUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CreateDockerRegistryWebhookUsingPOST creates a docker registry webhook

  Create a Docker Registry Webhook
*/
func (a *Client) CreateDockerRegistryWebhookUsingPOST(params *CreateDockerRegistryWebhookUsingPOSTParams, opts ...ClientOption) (*CreateDockerRegistryWebhookUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDockerRegistryWebhookUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createDockerRegistryWebhookUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/registry-webhooks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateDockerRegistryWebhookUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateDockerRegistryWebhookUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createDockerRegistryWebhookUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CreateGerritListenerUsingPOST creates a gerrit listener

  Create a Gerrit Listener
*/
func (a *Client) CreateGerritListenerUsingPOST(params *CreateGerritListenerUsingPOSTParams, opts ...ClientOption) (*CreateGerritListenerUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateGerritListenerUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createGerritListenerUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/gerrit-listeners",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateGerritListenerUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateGerritListenerUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createGerritListenerUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CreateGerritTriggerUsingPOST creates a gerrit trigger

  Create a Gerrit Trigger
*/
func (a *Client) CreateGerritTriggerUsingPOST(params *CreateGerritTriggerUsingPOSTParams, opts ...ClientOption) (*CreateGerritTriggerUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateGerritTriggerUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createGerritTriggerUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/gerrit-triggers",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateGerritTriggerUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateGerritTriggerUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createGerritTriggerUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CreateGitWebhookUsingPOST creates a git webhook

  Create a Git Webhook
*/
func (a *Client) CreateGitWebhookUsingPOST(params *CreateGitWebhookUsingPOSTParams, opts ...ClientOption) (*CreateGitWebhookUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateGitWebhookUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createGitWebhookUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/git-webhooks",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateGitWebhookUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateGitWebhookUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createGitWebhookUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteDockerRegistryEventByIDUsingDELETE deletes a docker registry event

  Delete a Docker Registry Event
*/
func (a *Client) DeleteDockerRegistryEventByIDUsingDELETE(params *DeleteDockerRegistryEventByIDUsingDELETEParams, opts ...ClientOption) (*DeleteDockerRegistryEventByIDUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDockerRegistryEventByIDUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteDockerRegistryEventByIdUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/registry-events/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteDockerRegistryEventByIDUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteDockerRegistryEventByIDUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteDockerRegistryEventByIdUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteDockerRegistryWebhookByIDUsingDELETE deletes a docker registry webhook

  Delete a Docker Registry Webhook
*/
func (a *Client) DeleteDockerRegistryWebhookByIDUsingDELETE(params *DeleteDockerRegistryWebhookByIDUsingDELETEParams, opts ...ClientOption) (*DeleteDockerRegistryWebhookByIDUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDockerRegistryWebhookByIDUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteDockerRegistryWebhookByIdUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/registry-webhooks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteDockerRegistryWebhookByIDUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteDockerRegistryWebhookByIDUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteDockerRegistryWebhookByIdUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteDockerRegistryWebhookByNameUsingDELETE deletes a docker registry webhook using name

  Delete a Docker Registry Webhook using name
*/
func (a *Client) DeleteDockerRegistryWebhookByNameUsingDELETE(params *DeleteDockerRegistryWebhookByNameUsingDELETEParams, opts ...ClientOption) (*DeleteDockerRegistryWebhookByNameUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDockerRegistryWebhookByNameUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteDockerRegistryWebhookByNameUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/registry-webhooks/{project}/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteDockerRegistryWebhookByNameUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteDockerRegistryWebhookByNameUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteDockerRegistryWebhookByNameUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteGerritEventByIDUsingDELETE deletes a gerrit event

  Delete a Gerrit Event
*/
func (a *Client) DeleteGerritEventByIDUsingDELETE(params *DeleteGerritEventByIDUsingDELETEParams, opts ...ClientOption) (*DeleteGerritEventByIDUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGerritEventByIDUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteGerritEventByIdUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/gerrit-events/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGerritEventByIDUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteGerritEventByIDUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteGerritEventByIdUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteGerritListenerByIDUsingDELETE deletes a gerrit listener with id

  Delete a Gerrit Listener with id
*/
func (a *Client) DeleteGerritListenerByIDUsingDELETE(params *DeleteGerritListenerByIDUsingDELETEParams, opts ...ClientOption) (*DeleteGerritListenerByIDUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGerritListenerByIDUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteGerritListenerByIdUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/gerrit-listeners/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGerritListenerByIDUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteGerritListenerByIDUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteGerritListenerByIdUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteGerritListenerByNameUsingDELETE deletes a gerrit listener with project and name

  Delete a Gerrit Listener with project and name
*/
func (a *Client) DeleteGerritListenerByNameUsingDELETE(params *DeleteGerritListenerByNameUsingDELETEParams, opts ...ClientOption) (*DeleteGerritListenerByNameUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGerritListenerByNameUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteGerritListenerByNameUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/gerrit-listeners/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGerritListenerByNameUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteGerritListenerByNameUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteGerritListenerByNameUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteGerritTriggerByIDUsingDELETE deletes a gerrit trigger with id

  Delete a Gerrit Trigger with id
*/
func (a *Client) DeleteGerritTriggerByIDUsingDELETE(params *DeleteGerritTriggerByIDUsingDELETEParams, opts ...ClientOption) (*DeleteGerritTriggerByIDUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGerritTriggerByIDUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteGerritTriggerByIdUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/gerrit-triggers/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGerritTriggerByIDUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteGerritTriggerByIDUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteGerritTriggerByIdUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteGerritTriggerByNameUsingDELETE deletes a gerrit trigger with project and name

  Delete a Gerrit Trigger with project and name
*/
func (a *Client) DeleteGerritTriggerByNameUsingDELETE(params *DeleteGerritTriggerByNameUsingDELETEParams, opts ...ClientOption) (*DeleteGerritTriggerByNameUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGerritTriggerByNameUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteGerritTriggerByNameUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/gerrit-triggers/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGerritTriggerByNameUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteGerritTriggerByNameUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteGerritTriggerByNameUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteGitEventsByIDUsingDELETE deletes a git event

  Delete a Git Event
*/
func (a *Client) DeleteGitEventsByIDUsingDELETE(params *DeleteGitEventsByIDUsingDELETEParams, opts ...ClientOption) (*DeleteGitEventsByIDUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGitEventsByIDUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteGitEventsByIdUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/git-events/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGitEventsByIDUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteGitEventsByIDUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteGitEventsByIdUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteGitWebhookByIDUsingDELETE deletes a git webhook

  Delete a Git Webhook
*/
func (a *Client) DeleteGitWebhookByIDUsingDELETE(params *DeleteGitWebhookByIDUsingDELETEParams, opts ...ClientOption) (*DeleteGitWebhookByIDUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGitWebhookByIDUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteGitWebhookByIdUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/git-webhooks/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGitWebhookByIDUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteGitWebhookByIDUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteGitWebhookByIdUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteGitWebhookByNameUsingDELETE deletes a git webhook by name

  Delete a Git Webhook by name
*/
func (a *Client) DeleteGitWebhookByNameUsingDELETE(params *DeleteGitWebhookByNameUsingDELETEParams, opts ...ClientOption) (*DeleteGitWebhookByNameUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGitWebhookByNameUsingDELETEParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteGitWebhookByNameUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/codestream/api/git-webhooks/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGitWebhookByNameUsingDELETEReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteGitWebhookByNameUsingDELETEOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteGitWebhookByNameUsingDELETE: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAllDockerRegistryEventsUsingGET gets all docker registry events

  Get all Docker Registry Events
*/
func (a *Client) GetAllDockerRegistryEventsUsingGET(params *GetAllDockerRegistryEventsUsingGETParams, opts ...ClientOption) (*GetAllDockerRegistryEventsUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllDockerRegistryEventsUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllDockerRegistryEventsUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/registry-events",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllDockerRegistryEventsUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAllDockerRegistryEventsUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAllDockerRegistryEventsUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAllDockerRegistryWebhooksUsingGET gets all docker registry webhooks

  Get all Docker Registry Webhooks
*/
func (a *Client) GetAllDockerRegistryWebhooksUsingGET(params *GetAllDockerRegistryWebhooksUsingGETParams, opts ...ClientOption) (*GetAllDockerRegistryWebhooksUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllDockerRegistryWebhooksUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllDockerRegistryWebhooksUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/registry-webhooks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllDockerRegistryWebhooksUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAllDockerRegistryWebhooksUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAllDockerRegistryWebhooksUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAllGerritEventsUsingGET gets all gerrit events

  Get all Gerrit Events
*/
func (a *Client) GetAllGerritEventsUsingGET(params *GetAllGerritEventsUsingGETParams, opts ...ClientOption) (*GetAllGerritEventsUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllGerritEventsUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllGerritEventsUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/gerrit-events",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllGerritEventsUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAllGerritEventsUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAllGerritEventsUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAllGerritListenersUsingGET gets all gerrit listeners

  Get all gerrit listeners
*/
func (a *Client) GetAllGerritListenersUsingGET(params *GetAllGerritListenersUsingGETParams, opts ...ClientOption) (*GetAllGerritListenersUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllGerritListenersUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllGerritListenersUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/gerrit-listeners",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllGerritListenersUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAllGerritListenersUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAllGerritListenersUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAllGerritTriggersUsingGET gets all gerrit triggers

  Get all gerrit triggers
*/
func (a *Client) GetAllGerritTriggersUsingGET(params *GetAllGerritTriggersUsingGETParams, opts ...ClientOption) (*GetAllGerritTriggersUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllGerritTriggersUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllGerritTriggersUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/gerrit-triggers",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllGerritTriggersUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAllGerritTriggersUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAllGerritTriggersUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAllGitEventsUsingGET gets all git events

  Get all Git Events
*/
func (a *Client) GetAllGitEventsUsingGET(params *GetAllGitEventsUsingGETParams, opts ...ClientOption) (*GetAllGitEventsUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllGitEventsUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllGitEventsUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/git-events",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllGitEventsUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAllGitEventsUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAllGitEventsUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAllGitWebhooksUsingGET gets all git webhooks

  Get all Git Webhooks
*/
func (a *Client) GetAllGitWebhooksUsingGET(params *GetAllGitWebhooksUsingGETParams, opts ...ClientOption) (*GetAllGitWebhooksUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllGitWebhooksUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllGitWebhooksUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/git-webhooks",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllGitWebhooksUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAllGitWebhooksUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAllGitWebhooksUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetDockerRegistryWebhookNameUsingGET gets a docker registry webhook by name

  Get a Docker Registry Webhook by Name
*/
func (a *Client) GetDockerRegistryWebhookNameUsingGET(params *GetDockerRegistryWebhookNameUsingGETParams, opts ...ClientOption) (*GetDockerRegistryWebhookNameUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDockerRegistryWebhookNameUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDockerRegistryWebhookNameUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/registry-webhooks/{project}/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetDockerRegistryWebhookNameUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDockerRegistryWebhookNameUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getDockerRegistryWebhookNameUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetGerritEventByIDUsingGET gets a gerrit event

  Get a gerrit Event based on id
*/
func (a *Client) GetGerritEventByIDUsingGET(params *GetGerritEventByIDUsingGETParams, opts ...ClientOption) (*GetGerritEventByIDUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGerritEventByIDUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getGerritEventByIDUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/gerrit-events/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGerritEventByIDUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetGerritEventByIDUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGerritEventByIDUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetGerritListenerByIDUsingGET gets a gerrit listener

  Get a gerrit listeners based on id
*/
func (a *Client) GetGerritListenerByIDUsingGET(params *GetGerritListenerByIDUsingGETParams, opts ...ClientOption) (*GetGerritListenerByIDUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGerritListenerByIDUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getGerritListenerByIDUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/gerrit-listeners/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGerritListenerByIDUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetGerritListenerByIDUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGerritListenerByIDUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetGerritListenerByNameUsingGET gets a gerrit listener by project and name

  Get a gerrit listener based on project and name
*/
func (a *Client) GetGerritListenerByNameUsingGET(params *GetGerritListenerByNameUsingGETParams, opts ...ClientOption) (*GetGerritListenerByNameUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGerritListenerByNameUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getGerritListenerByNameUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/gerrit-listeners/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGerritListenerByNameUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetGerritListenerByNameUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGerritListenerByNameUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetGerritProjectsByIDUsingGET gets gerrit projects from the gerrit listener using id

  Get Gerrit Projects from the Gerrit Listener using id
*/
func (a *Client) GetGerritProjectsByIDUsingGET(params *GetGerritProjectsByIDUsingGETParams, opts ...ClientOption) (*GetGerritProjectsByIDUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGerritProjectsByIDUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getGerritProjectsByIdUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/gerrit-listeners/{id}/projects",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGerritProjectsByIDUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetGerritProjectsByIDUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGerritProjectsByIdUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetGerritProjectsByNameUsingGET gets gerrit projects from the gerrit listener using project and name

  Get Gerrit Projects from the Gerrit Listener using project and name
*/
func (a *Client) GetGerritProjectsByNameUsingGET(params *GetGerritProjectsByNameUsingGETParams, opts ...ClientOption) (*GetGerritProjectsByNameUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGerritProjectsByNameUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getGerritProjectsByNameUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/gerrit-listeners/{project}/{name}/projects",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGerritProjectsByNameUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetGerritProjectsByNameUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGerritProjectsByNameUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetGerritTriggerByIDUsingGET gets a gerrit trigger

  Get a gerrit trigger based on id
*/
func (a *Client) GetGerritTriggerByIDUsingGET(params *GetGerritTriggerByIDUsingGETParams, opts ...ClientOption) (*GetGerritTriggerByIDUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGerritTriggerByIDUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getGerritTriggerByIdUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/gerrit-triggers/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGerritTriggerByIDUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetGerritTriggerByIDUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGerritTriggerByIdUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetGerritTriggerByNameUsingGET gets a gerrit trigger by project and name

  Get a gerrit trigger based on project and name
*/
func (a *Client) GetGerritTriggerByNameUsingGET(params *GetGerritTriggerByNameUsingGETParams, opts ...ClientOption) (*GetGerritTriggerByNameUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGerritTriggerByNameUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getGerritTriggerByNameUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/gerrit-triggers/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGerritTriggerByNameUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetGerritTriggerByNameUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGerritTriggerByNameUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetGitEventByIDUsingGET gets a git event

  Get a Git Event based on id
*/
func (a *Client) GetGitEventByIDUsingGET(params *GetGitEventByIDUsingGETParams, opts ...ClientOption) (*GetGitEventByIDUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGitEventByIDUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getGitEventByIDUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/git-events/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGitEventByIDUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetGitEventByIDUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGitEventByIDUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetGitWebhookByIDUsingGET gets a git webhook

  Get a Git Webhook based on id
*/
func (a *Client) GetGitWebhookByIDUsingGET(params *GetGitWebhookByIDUsingGETParams, opts ...ClientOption) (*GetGitWebhookByIDUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGitWebhookByIDUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getGitWebhookByIDUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/git-webhooks/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGitWebhookByIDUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetGitWebhookByIDUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGitWebhookByIDUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetGitWebhookByNameUsingGET gets a git webhook by name

  Get a Git Webhook by Name
*/
func (a *Client) GetGitWebhookByNameUsingGET(params *GetGitWebhookByNameUsingGETParams, opts ...ClientOption) (*GetGitWebhookByNameUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGitWebhookByNameUsingGETParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getGitWebhookByNameUsingGET",
		Method:             "GET",
		PathPattern:        "/codestream/api/git-webhooks/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGitWebhookByNameUsingGETReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetGitWebhookByNameUsingGETOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGitWebhookByNameUsingGET: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRegistryEventByID gets a docker registry event

  Get a Docker Registry Event based on id
*/
func (a *Client) GetRegistryEventByID(params *GetRegistryEventByIDParams, opts ...ClientOption) (*GetRegistryEventByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRegistryEventByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getRegistryEventByID",
		Method:             "GET",
		PathPattern:        "/codestream/api/registry-events/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRegistryEventByIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRegistryEventByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getRegistryEventByID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRegistryWebhookByID gets a docker registry webhook

  Get a Docker Registry Webhook based on id
*/
func (a *Client) GetRegistryWebhookByID(params *GetRegistryWebhookByIDParams, opts ...ClientOption) (*GetRegistryWebhookByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRegistryWebhookByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getRegistryWebhookByID",
		Method:             "GET",
		PathPattern:        "/codestream/api/registry-webhooks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRegistryWebhookByIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRegistryWebhookByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getRegistryWebhookByID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ManualGerritEventTriggerUsingPOST manuals trigger gerrit event

  Manual trigger Gerrit event
*/
func (a *Client) ManualGerritEventTriggerUsingPOST(params *ManualGerritEventTriggerUsingPOSTParams, opts ...ClientOption) (*ManualGerritEventTriggerUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewManualGerritEventTriggerUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "manualGerritEventTriggerUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/gerrit-events",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ManualGerritEventTriggerUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ManualGerritEventTriggerUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for manualGerritEventTriggerUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PatchDockerRegistryWebhookByIDUsingPATCH patches a docker registry webhook with id

  Patch a Docker Registry Webhook with id
*/
func (a *Client) PatchDockerRegistryWebhookByIDUsingPATCH(params *PatchDockerRegistryWebhookByIDUsingPATCHParams, opts ...ClientOption) (*PatchDockerRegistryWebhookByIDUsingPATCHOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchDockerRegistryWebhookByIDUsingPATCHParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchDockerRegistryWebhookByIdUsingPATCH",
		Method:             "PATCH",
		PathPattern:        "/codestream/api/registry-webhooks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchDockerRegistryWebhookByIDUsingPATCHReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchDockerRegistryWebhookByIDUsingPATCHOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for patchDockerRegistryWebhookByIdUsingPATCH: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PatchDockerRegistryWebhookByNameUsingPATCH patches a docker registry webhook with project and name

  Patch a Docker Registry Webhook with project and name
*/
func (a *Client) PatchDockerRegistryWebhookByNameUsingPATCH(params *PatchDockerRegistryWebhookByNameUsingPATCHParams, opts ...ClientOption) (*PatchDockerRegistryWebhookByNameUsingPATCHOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchDockerRegistryWebhookByNameUsingPATCHParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchDockerRegistryWebhookByNameUsingPATCH",
		Method:             "PATCH",
		PathPattern:        "/codestream/api/registry-webhooks/{project}/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchDockerRegistryWebhookByNameUsingPATCHReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchDockerRegistryWebhookByNameUsingPATCHOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for patchDockerRegistryWebhookByNameUsingPATCH: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PatchGerritListenerByIDUsingPATCH patches a gerrit listener with id

  Patch a Gerrit Listener with id
*/
func (a *Client) PatchGerritListenerByIDUsingPATCH(params *PatchGerritListenerByIDUsingPATCHParams, opts ...ClientOption) (*PatchGerritListenerByIDUsingPATCHOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchGerritListenerByIDUsingPATCHParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchGerritListenerByIdUsingPATCH",
		Method:             "PATCH",
		PathPattern:        "/codestream/api/gerrit-listeners/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchGerritListenerByIDUsingPATCHReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchGerritListenerByIDUsingPATCHOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for patchGerritListenerByIdUsingPATCH: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PatchGerritListenerByNameUsingPATCH patches a gerrit listener with project and name

  Patch a Gerrit Listener with project and name
*/
func (a *Client) PatchGerritListenerByNameUsingPATCH(params *PatchGerritListenerByNameUsingPATCHParams, opts ...ClientOption) (*PatchGerritListenerByNameUsingPATCHOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchGerritListenerByNameUsingPATCHParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchGerritListenerByNameUsingPATCH",
		Method:             "PATCH",
		PathPattern:        "/codestream/api/gerrit-listeners/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchGerritListenerByNameUsingPATCHReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchGerritListenerByNameUsingPATCHOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for patchGerritListenerByNameUsingPATCH: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PatchGerritTriggerByIDUsingPATCH patches a gerrit trigger with id

  Patch a Gerrit Trigger with id
*/
func (a *Client) PatchGerritTriggerByIDUsingPATCH(params *PatchGerritTriggerByIDUsingPATCHParams, opts ...ClientOption) (*PatchGerritTriggerByIDUsingPATCHOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchGerritTriggerByIDUsingPATCHParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchGerritTriggerByIdUsingPATCH",
		Method:             "PATCH",
		PathPattern:        "/codestream/api/gerrit-triggers/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchGerritTriggerByIDUsingPATCHReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchGerritTriggerByIDUsingPATCHOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for patchGerritTriggerByIdUsingPATCH: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PatchGerritTriggerByNameUsingPATCH patches a gerrit trigger with project and name

  Patch a Gerrit Trigger with project and name
*/
func (a *Client) PatchGerritTriggerByNameUsingPATCH(params *PatchGerritTriggerByNameUsingPATCHParams, opts ...ClientOption) (*PatchGerritTriggerByNameUsingPATCHOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchGerritTriggerByNameUsingPATCHParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchGerritTriggerByNameUsingPATCH",
		Method:             "PATCH",
		PathPattern:        "/codestream/api/gerrit-triggers/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchGerritTriggerByNameUsingPATCHReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchGerritTriggerByNameUsingPATCHOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for patchGerritTriggerByNameUsingPATCH: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ResumeOrRerunDockerRegistryEventUsingPOST res run resume docker registry event

  Re-run/Resume Docker Registry Event
*/
func (a *Client) ResumeOrRerunDockerRegistryEventUsingPOST(params *ResumeOrRerunDockerRegistryEventUsingPOSTParams, opts ...ClientOption) (*ResumeOrRerunDockerRegistryEventUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewResumeOrRerunDockerRegistryEventUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "resumeOrRerunDockerRegistryEventUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/registry-events/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ResumeOrRerunDockerRegistryEventUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ResumeOrRerunDockerRegistryEventUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for resumeOrRerunDockerRegistryEventUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ResumeOrRerunGerritEventUsingPOST res run resume gerrit event

  Re-run/Resume Gerrit event
*/
func (a *Client) ResumeOrRerunGerritEventUsingPOST(params *ResumeOrRerunGerritEventUsingPOSTParams, opts ...ClientOption) (*ResumeOrRerunGerritEventUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewResumeOrRerunGerritEventUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "resumeOrRerunGerritEventUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/gerrit-events/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ResumeOrRerunGerritEventUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ResumeOrRerunGerritEventUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for resumeOrRerunGerritEventUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ResumeOrRerunGitEventUsingPOST res run resume git event

  Re-run/Resume Git Event
*/
func (a *Client) ResumeOrRerunGitEventUsingPOST(params *ResumeOrRerunGitEventUsingPOSTParams, opts ...ClientOption) (*ResumeOrRerunGitEventUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewResumeOrRerunGitEventUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "resumeOrRerunGitEventUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/git-events/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ResumeOrRerunGitEventUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ResumeOrRerunGitEventUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for resumeOrRerunGitEventUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateDockerRegistryWebhookByIDUsingPUT updates a docker registry webhook

  Update a Docker Registry Webhook
*/
func (a *Client) UpdateDockerRegistryWebhookByIDUsingPUT(params *UpdateDockerRegistryWebhookByIDUsingPUTParams, opts ...ClientOption) (*UpdateDockerRegistryWebhookByIDUsingPUTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateDockerRegistryWebhookByIDUsingPUTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateDockerRegistryWebhookByIdUsingPUT",
		Method:             "PUT",
		PathPattern:        "/codestream/api/registry-webhooks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateDockerRegistryWebhookByIDUsingPUTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateDockerRegistryWebhookByIDUsingPUTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateDockerRegistryWebhookByIdUsingPUT: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateDockerRegistryWebhookByNameUsingPUT updates a docker registry webhook using name

  Update a Docker Registry Webhook using name
*/
func (a *Client) UpdateDockerRegistryWebhookByNameUsingPUT(params *UpdateDockerRegistryWebhookByNameUsingPUTParams, opts ...ClientOption) (*UpdateDockerRegistryWebhookByNameUsingPUTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateDockerRegistryWebhookByNameUsingPUTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateDockerRegistryWebhookByNameUsingPUT",
		Method:             "PUT",
		PathPattern:        "/codestream/api/registry-webhooks/{project}/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateDockerRegistryWebhookByNameUsingPUTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateDockerRegistryWebhookByNameUsingPUTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateDockerRegistryWebhookByNameUsingPUT: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateGerritListenerByIDUsingPUT updates a gerrit listener with id

  Update a Gerrit Listener with id
*/
func (a *Client) UpdateGerritListenerByIDUsingPUT(params *UpdateGerritListenerByIDUsingPUTParams, opts ...ClientOption) (*UpdateGerritListenerByIDUsingPUTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGerritListenerByIDUsingPUTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateGerritListenerByIdUsingPUT",
		Method:             "PUT",
		PathPattern:        "/codestream/api/gerrit-listeners/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateGerritListenerByIDUsingPUTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateGerritListenerByIDUsingPUTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateGerritListenerByIdUsingPUT: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateGerritListenerByNameUsingPUT updates a gerrit listener with project and name

  Update a Gerrit Listener with project and name
*/
func (a *Client) UpdateGerritListenerByNameUsingPUT(params *UpdateGerritListenerByNameUsingPUTParams, opts ...ClientOption) (*UpdateGerritListenerByNameUsingPUTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGerritListenerByNameUsingPUTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateGerritListenerByNameUsingPUT",
		Method:             "PUT",
		PathPattern:        "/codestream/api/gerrit-listeners/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateGerritListenerByNameUsingPUTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateGerritListenerByNameUsingPUTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateGerritListenerByNameUsingPUT: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateGerritTriggerByIDUsingPUT updates a gerrit trigger with id

  Update a Gerrit Trigger with id
*/
func (a *Client) UpdateGerritTriggerByIDUsingPUT(params *UpdateGerritTriggerByIDUsingPUTParams, opts ...ClientOption) (*UpdateGerritTriggerByIDUsingPUTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGerritTriggerByIDUsingPUTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateGerritTriggerByIdUsingPUT",
		Method:             "PUT",
		PathPattern:        "/codestream/api/gerrit-triggers/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateGerritTriggerByIDUsingPUTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateGerritTriggerByIDUsingPUTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateGerritTriggerByIdUsingPUT: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateGerritTriggerByNameUsingPUT updates a gerrit trigger with project and name

  Update a Gerrit Trigger with project and name
*/
func (a *Client) UpdateGerritTriggerByNameUsingPUT(params *UpdateGerritTriggerByNameUsingPUTParams, opts ...ClientOption) (*UpdateGerritTriggerByNameUsingPUTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGerritTriggerByNameUsingPUTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateGerritTriggerByNameUsingPUT",
		Method:             "PUT",
		PathPattern:        "/codestream/api/gerrit-triggers/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateGerritTriggerByNameUsingPUTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateGerritTriggerByNameUsingPUTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateGerritTriggerByNameUsingPUT: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateGitWebhookByIDUsingPUT updates a git webhook

  Update a Git Webhook
*/
func (a *Client) UpdateGitWebhookByIDUsingPUT(params *UpdateGitWebhookByIDUsingPUTParams, opts ...ClientOption) (*UpdateGitWebhookByIDUsingPUTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGitWebhookByIDUsingPUTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateGitWebhookByIdUsingPUT",
		Method:             "PUT",
		PathPattern:        "/codestream/api/git-webhooks/{id}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateGitWebhookByIDUsingPUTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateGitWebhookByIDUsingPUTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateGitWebhookByIdUsingPUT: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateGitWebhookByNameUsingPUT updates a git webhook using name

  Update a Git Webhook using name
*/
func (a *Client) UpdateGitWebhookByNameUsingPUT(params *UpdateGitWebhookByNameUsingPUTParams, opts ...ClientOption) (*UpdateGitWebhookByNameUsingPUTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateGitWebhookByNameUsingPUTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateGitWebhookByNameUsingPUT",
		Method:             "PUT",
		PathPattern:        "/codestream/api/git-webhooks/{project}/{name}",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateGitWebhookByNameUsingPUTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateGitWebhookByNameUsingPUTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateGitWebhookByNameUsingPUT: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ValidateGerritListenerUsingPOST validates a gerrit listener

  Validate a Gerrit Listener
*/
func (a *Client) ValidateGerritListenerUsingPOST(params *ValidateGerritListenerUsingPOSTParams, opts ...ClientOption) (*ValidateGerritListenerUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewValidateGerritListenerUsingPOSTParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "validateGerritListenerUsingPOST",
		Method:             "POST",
		PathPattern:        "/codestream/api/gerrit-listeners/validate",
		ProducesMediaTypes: []string{"*/*"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ValidateGerritListenerUsingPOSTReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ValidateGerritListenerUsingPOSTOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for validateGerritListenerUsingPOST: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
